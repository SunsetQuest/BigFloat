
2/1/2025 version
    /// <summary>
    /// This number will take a BigInteger and return the bits to the right side of the decimal point. 
    /// Example: Inverse of 0b11011(i.e. 18) would be 0.037037 and returned as 0b00010010(i.e. 18).
    /// Note: Initial version of this was started with ChatGPT but it was not Newton Plus. (see inverseNotes.txt)
    /// </summary>
    /// <param name="x">The value you want to find the inverse (1/x) of x. Negative values are allowed.</param>
    /// <param name="requestedPrecision"></param>
    /// <returns></returns>
    /// <exception cref="DivideByZeroException">if x is zero, then the inverse is undefined or infinity.</exception>
    /// <exception cref="ArgumentException">A negative requested Precision is not allowed.</exception>
    public static BigInteger Inverse(BigInteger x, int requestedPrecision = 0)
    {
        int xLen = (int)x.GetBitLength();
        if (x.IsZero)
        {
            throw new DivideByZeroException("'x' can not be 0.");
        }
        if (requestedPrecision <= 0)
        {
            if (requestedPrecision < 0)
            {
                throw new ArgumentException("'precisionBits' can not be negative.");
            }
            requestedPrecision = xLen;
        }

        // future: can we pre-shrink x to requestedPrecision OR just keep 32 bits past the
        // precision? This can cause an inaccurate result (a round up for results like 122.999999
        // to 123 on the result) however might offer better performance in some cases.

        // Trailing Zeros never matter
        int trailingZeros = (int)BigInteger.TrailingZeroCount(x);
        if (trailingZeros + 1 == xLen)
        {
            return (BigInteger.One * x.Sign) << trailingZeros;
        }
        x >>= trailingZeros;
        xLen -= trailingZeros;

        // Tuning constants     error at:                             
        const int SIMPLE_CUTOFF =   1024; // 1024
        const int EXTRA_START =        4; //    4
        const int START_CUTOFF =     400; //  400
        const int NEWTON_CUTOFF =    800; //  800
        const int EXTRA_TO_REMOVE1 =   2; //    2
        const int SKIP_LOWEST =        0; //    0
        const int EXTRA_TO_REMOVE2 =   1; //    1
        const int BOOST_LARGER_NUMS=   2; //    2

        if ((requestedPrecision + xLen) <= SIMPLE_CUTOFF)
            return (BigInteger.One << (xLen +  requestedPrecision - 1)) / x;

        bool isPos = x.Sign >= 0;
        if (!isPos)
            x = -x;

        // The larger the number the more buffer we should start out with we can then reduce the
        // buffer as we go along.

        ////////  Get Starting Size  ////////
        int desiredStartSize = requestedPrecision + (EXTRA_START * 2);
        while (desiredStartSize > START_CUTOFF)
        {
            desiredStartSize = ((desiredStartSize+1) >> 1) + BOOST_LARGER_NUMS;
        }
        int curSize = desiredStartSize;

        BigInteger scaledOne2 = BigInteger.One << ((curSize << 1) + (EXTRA_START * 2));
        BigInteger result = scaledOne2 / (x >> (xLen - curSize - 1 - EXTRA_START));
        curSize += EXTRA_START;

        ////////////////////// Newton version  //////////////////////
        while (true)
        {
            int doubleCurSize = curSize << 1;

            BigInteger scalingFactor = BigInteger.One << (doubleCurSize + 1);
            BigInteger xTimesY = ((x >> (xLen - doubleCurSize)) * result) >> (curSize - 1); 
            // future: we only need the bottom half of this.
            BigInteger twoMinusXy = scalingFactor - xTimesY;
            result *= twoMinusXy;

            int pendingInaccurateBottomHalfToRemove = (curSize + EXTRA_TO_REMOVE1);
            curSize = doubleCurSize - EXTRA_TO_REMOVE1;

            if (curSize > ((requestedPrecision < NEWTON_CUTOFF * 2) ? requestedPrecision : NEWTON_CUTOFF))
            {
                if (curSize > requestedPrecision)
                {
                    BigInteger tempResult2 = (result) >> (curSize - requestedPrecision + pendingInaccurateBottomHalfToRemove);
                    return isPos ? tempResult2 : -tempResult2;
                }
                result = (result ) >> pendingInaccurateBottomHalfToRemove + SKIP_LOWEST;
                break;
            }

            result >>= pendingInaccurateBottomHalfToRemove;
        }

        // future: can we merge the "result >>= SKIP_LOWEST;" into the result shift above?

        // Lets make sure we are 100% accurate at this point - back off until we see both a 0 and 1
        int reduceBy2 = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : (~result)) + 1;
        if (reduceBy2 < 32) // 32 is flexible
        {
            result >>= reduceBy2;
            curSize -= reduceBy2 + SKIP_LOWEST;
        }
        else
        {
            // if we have something with lots of trailing zeros or ones, lets just use the classic
            // method to ensure correctness.
            BigInteger res = (BigInteger.One << (xLen + ((requestedPrecision == 0) ? xLen : requestedPrecision) - 1)) / x;
            return isPos ? res : -res;
        }

        ////////////////////// NewtonPlus version  ////////////////////// Let's shift into high gear...
        if (curSize > requestedPrecision)
        {
            BigInteger tempResult2 = result >> (curSize - requestedPrecision);
            return isPos ? tempResult2 : (-tempResult2);
        }

        while (true)
        {
            int doubleCurSize = curSize << 1;

            // We need insert our "1" in the middle, we do this by incrementing the upper half with a 1
            result++; // we could just do a add a "(1 << doublecurSize)"
            BigInteger mask = (BigInteger.One << (curSize + 1)) - 1;
            BigInteger xTimesY = ((x >> (xLen - doubleCurSize)) * result) >> (curSize - 1); // future: we only need the bottom half of this.

            //// back off until we see both a zero and one
            if (doubleCurSize - EXTRA_TO_REMOVE2 > requestedPrecision) // maybe remove EXTRA_TO_REMOVE2
            {
                result = ((result << (2 * curSize - 0)) - ((result >> 0) * (xTimesY & mask))) >> (3 * curSize - 0 - requestedPrecision);

                return isPos ? result : -result;
            }
            result = ((result << (doubleCurSize)) - (result * (xTimesY & mask))) >> (curSize + EXTRA_TO_REMOVE2);

            curSize = doubleCurSize - EXTRA_TO_REMOVE2;

            int reduceBy = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : ~result) + 1;
            if (reduceBy < 100)
            {
                result >>= reduceBy;
                curSize -= reduceBy;
            }
        }
    }

/////////////////// 1/25/2025/////////////////

    public static BigInteger InverseClassic(BigInteger x, int requestedPrecision = 0)
    {
        int xLen = (int)x.GetBitLength();

        if (requestedPrecision == 0)
        {
            requestedPrecision = xLen;
        }
        else if (requestedPrecision < 0)
        {
            throw new DivideByZeroException("'precisionBits' can not be negative.");
        }
        
        if (x.IsPowerOfTwo)
        {
            return (BigInteger.One * x.Sign) << (int)BigInteger.TrailingZeroCount(x);
        }

        return (BigInteger.One << (xLen + ((requestedPrecision == 0) ? xLen : requestedPrecision) - 1)) / x;
    }


    public static BigInteger Inverse(BigInteger x, int requestedPrecision = 0)
    {
        //uint(x & uint.MaxValue)
        int xLen = (int)x.GetBitLength();
        if (x.IsZero)
        {
            throw new DivideByZeroException("'x' can not be 0.");
        }
        if (requestedPrecision <= 0)
        {
            if (requestedPrecision < 0)
            {
                throw new ArgumentException("'precisionBits' can not be negative.");
            }
            requestedPrecision = xLen;
        }

        // can we pre-shrink x to requestedPrecision? (or just keep 32 bits?)


        // Trailing Zeros never matter
        int trailingZeros = (int)BigInteger.TrailingZeroCount(x);
        if (trailingZeros + 1 == xLen)
        {
            return (BigInteger.One * x.Sign) << trailingZeros;
        }
        x >>= trailingZeros;
        xLen -= trailingZeros;


        // Tuning constants     error at:                             
        const int SIMPLE_CUTOFF =   1024; // 1024
        const int EXTRA_START =        4; //    4
        const int START_CUTOFF =     400; //  400
        const int NEWTON_CUTOFF =    800; //  800
        const int EXTRA_TO_REMOVE1 =   2; //    2
        const int SKIP_LOWEST =        0; //    0
        const int EXTRA_TO_REMOVE2 =   1; //    1
        const int BOOST_LARGER_NUMS=   2; //    2
        //========================================================================================================
        //                                    291                       


        if ((requestedPrecision + xLen) <= SIMPLE_CUTOFF)
            return (BigInteger.One << (xLen + ((requestedPrecision == 0) ? xLen : requestedPrecision) - 1)) / x;

        bool isPos = x.Sign >= 0;
        if (!isPos)
            x = -x;

        const bool dbug = false;

        //the bigger the number the more buffer we should start out with
        //we can then reduce the buffer as we go along.

        ////////  Get Starting Size  ////////
        int desiredStartSize = requestedPrecision + (EXTRA_START * 2);
        int loops = 0;
        while (desiredStartSize > START_CUTOFF)
        {
            desiredStartSize = ((desiredStartSize+1) >> 1) + BOOST_LARGER_NUMS;
            if (dbug) loops++;
        }
        int curSize = desiredStartSize;

        BigInteger scaledOne2 = BigInteger.One << ((curSize << 1) + (EXTRA_START * 2));
        BigInteger result = scaledOne2 / (x >> (xLen - curSize - 1 - EXTRA_START));
        curSize += EXTRA_START;


        if (dbug) Console.WriteLine($"");
        ////////////////////// Newton version  //////////////////////
        // what about a fixed number of loops?
        //while (curSize <= Math.Min(NEWTON_CUTOFF, requestedPrecision)) // When we reach out 1000 bits lets move to NewtonPlus as it is slightly faster.
        //if (curSize <= requestedPrecision)
        //for (int i = 0; i < 2; i++)

        // 1024 - cut off      but calc to 1024
        // 1500 - cut off      but calc to 1500+100
        // 2048 - skip to next but calc to 1024

        int cuttoff = Math.Min(NEWTON_CUTOFF, requestedPrecision);
        while (true)
        {
            int doubleCurSize = curSize << 1;

            if (dbug) Console.Write($"{(((double)(curSize << loops) / requestedPrecision) + "     ")[..4]} [{(curSize << loops) - requestedPrecision}]  ");

            BigInteger scalingFactor = BigInteger.One << (doubleCurSize + 1);
            BigInteger xTimesY = ((x >> (xLen - doubleCurSize)) * result) >> (curSize - 1); // future: we only need the bottom half of this.
            BigInteger twoMinusXy = scalingFactor - xTimesY;
            result *= twoMinusXy;

            int pendingInaccurateBottomHalfToRemove = (curSize + EXTRA_TO_REMOVE1);
            curSize = doubleCurSize - EXTRA_TO_REMOVE1;

            if (dbug) loops--;
            //if (curSize > cuttoff) break;
            if (curSize > ((requestedPrecision < NEWTON_CUTOFF * 2) ? requestedPrecision : NEWTON_CUTOFF))
            {
                if (curSize > requestedPrecision)
                {
                    //Console.WriteLine($"return result:[{result.GetBitLength()}] >> {curSize - requestedPrecision + pendingInaccurateBottomHalfToRemove}");
                    BigInteger tempResult2 = (result) >> (curSize - requestedPrecision + pendingInaccurateBottomHalfToRemove);
                    return isPos ? tempResult2 : -tempResult2;
                }
                result = (result ) >> pendingInaccurateBottomHalfToRemove + SKIP_LOWEST;
                //Console.WriteLine($"exit   result:[{result.GetBitLength()}] >> a({pendingInaccurateBottomHalfToRemove}) + {SKIP_LOWEST}");
                //Console.WriteLine($"{requestedPrecision,10}:  {curSize} > {((requestedPrecision < NEWTON_CUTOFF * 2) ? requestedPrecision : NEWTON_CUTOFF)}");
                break;
            }

            result >>= pendingInaccurateBottomHalfToRemove;
            //pendingInaccurateBottomHalfToRemove = 0;
            //// is last loop???  we should reduce the size - is this needed since it should start with the correct size????
            //if (curSize * 2 > requestedPrecision)
            //{
            //    int diff = curSize * 2 - requestedPrecision;
            //    Console.WriteLine($"1-more result:[{result.GetBitLength()}] >> {diff}  (OR curSize({curSize})*2 - {requestedPrecision})");
            //    //result >>= diff;
            //    //curSize -= diff;
            //}
        }

        // can we merge the "result >>= SKIP_LOWEST;" into the result shift above?

        // Lets make sure we are 100% accurate at this point.
        //result >>= SKIP_LOWEST;
        // back off until we see both a zero and one
        int reduceBy2 = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : (~result)) + 1; // need one for things like ..100000
        if (reduceBy2 < 32) // 32 is flexible
        {
            result >>= reduceBy2;
            curSize -= reduceBy2 + SKIP_LOWEST;
        }
        else
        {
            // if we have something with lots of trailing zeros or ones, lets just use the classic method to ensure correctness.
            BigInteger res = (BigInteger.One << (xLen + ((requestedPrecision == 0) ? xLen : requestedPrecision) - 1)) / x;
            return isPos ? res : -res;
        }

        //CheckIfCorrectSoFar(x, xLen, curSize, result);


        ////////////////////// NewtonPlus version  ////////////////////// Let's shift into high gear...
        if (curSize > requestedPrecision)
        {
            BigInteger tempResult2 = result >> (curSize - requestedPrecision);
            return isPos ? tempResult2 : (-tempResult2);
        }

        while (true)
        {
            int doubleCurSize = curSize << 1;

            //if ((double)doubleCurSize / requestedPrecision > 0.9)
            if (dbug) Console.Write($"{(((double)(curSize << loops) / requestedPrecision) + "     ")[..4]} [{(curSize << loops) - requestedPrecision}]  ");

            // We need insert our "1" in the middle, we do this by incrementing the upper half with a 1
            result++; // we could just do a add a "(1 << doublecurSize)"
            BigInteger mask22 = (BigInteger.One << (curSize + 1)) - 1;
            BigInteger xTimesY22 = ((x >> (xLen - doubleCurSize)) * result) >> (curSize - 1); // future: we only need the bottom half of this.

            //// back off until we see both a zero and one

            if (doubleCurSize - EXTRA_TO_REMOVE2 > requestedPrecision) // maybe remove EXTRA_TO_REMOVE2
            {
                //curSize = doubleCurSize - EXTRA_TO_REMOVE2;
                //if (result.GetBitLength() > requestedPrecision * 1.1) Console.WriteLine($"  {result.GetBitLength()} > {requestedPrecision * 1.1}");
                result = ((result << (2 * curSize - 0)) - ((result >> 0) * (xTimesY22 & mask22))) >> (3 * curSize - 0 - requestedPrecision);


                return isPos ? result : -result;
            }
            result = ((result << (doubleCurSize)) - (result * (xTimesY22 & mask22))) >> (curSize + EXTRA_TO_REMOVE2);

            curSize = doubleCurSize - EXTRA_TO_REMOVE2;

            int reduceBy = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : ~result) + 1;
            if (reduceBy < 100)
            {
                result >>= reduceBy;
                curSize -= reduceBy;
            }
            else
            {
            }

            //CheckIfCorrectSoFar(x, xLen, curSize, result);

            if (dbug) loops--;
        }

        //if (dbug) Console.Write($"{(((double)(curSize << loops) / requestedPrecision) + "     ")[..4]} [{(curSize << loops) - requestedPrecision}]  ");

        ////if (trailingZeros> 14) Console.Write(trailingZeros);

        //if (result.GetBitLength()/4 < curSize - requestedPrecision) Console.WriteLine($"  {result.GetBitLength() / 4} < {curSize - requestedPrecision}");

        //BigInteger tempResult = result >> (curSize - requestedPrecision);
        //return isPos ? tempResult : (-tempResult);

        // Check if correct so far and output info if not
        static void CheckIfCorrectSoFar(BigInteger x, int xLen, int curSize, BigInteger result)
        {
            BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
            int correctBits2 = ToBinaryString(result).Zip(ToBinaryString(checkResult), static (c1, c2) => c1 == c2).TakeWhile(static b => b).Count();
            if (correctBits2 < Math.Min(curSize, checkResult.GetBitLength()))
                Console.WriteLine($"not 100% !!\r\nAns: {ToBinaryString(checkResult)}[{checkResult.GetBitLength()}]\r\nRes: {ToBinaryString(result)}[{result.GetBitLength()}]");
    }
    }


///////////////////// as of 12/29/2024 - Ryan Scott White //////////////////////////////
    public static BigInteger InverseBigInteger9(BigInteger x, int requestedPrecision = 0)
    {
        int xLen = (int)x.GetBitLength();
        if (requestedPrecision <= 0)
        {
            if (requestedPrecision < 0)
                throw new DivideByZeroException("'precisionBits' can not be negative.");
            requestedPrecision = xLen;
        }

        bool isPos = x.Sign >= 0;
        if (!isPos)
            x = -x;

        // can we pre-shrink x to requestedPrecision? (or just keep 32 bits?)

        //// Trailing Zeros never matter
        int trailingZeros = (int)BigInteger.TrailingZeroCount(x);
        x >>= trailingZeros;
        xLen -= trailingZeros;

        // 111111111111101100111110000000001000111000111100010000110100110010100000011110011111000.01
        // 11111111111110110011111000000000100011100011110001000011010011000  (res)
        // 11111111111110110011111000000000100011100011110001000011010011001  (ans)

        //  x         requestedPrecision Can Be
        // 1101[4]  -> 128-4  =124
        // 1101[64] -> 128-64 =64
        // 1101[100]-> 128-100=28
        if ((requestedPrecision + xLen) <= 128)
        {
            ulong x2 = (ulong)x;
            //int leadingZeros= (int)ulong.LeadingZeroCount(x2);

            // or if xLen = 33 then requestedPrecision <34
            if ((requestedPrecision + xLen) <= 64)
            {
                ulong result64 = (1UL << 63) / x2; // 63 /  31
                result64 >>= 64- (int)ulong.LeadingZeroCount(result64) - requestedPrecision;
                return isPos ? result64 : (-(BigInteger)result64);
            }
#if (NET7_0_OR_GREATER)
            UInt128 result128 = (UInt128.One << 127) / x2;
            result128 >>= (int)UInt128.Log2(result128) + 1 - requestedPrecision; //what about ulong.Log2(res>>64) +64
            return isPos ? result128 : (-(BigInteger)result128);
#endif
        }

        if ((requestedPrecision + xLen) <= 1024)
        {
            BigInteger resultBI = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
            return isPos ? resultBI : (-resultBI);
        }

        const bool dbug = false;

        ////////  Get Starting Size  //////// 8-282 7-281 6-285 5-297 4-290 3-293 2-299 1-271
        const int EXTRA = 4;
        int desiredStartSize = requestedPrecision + EXTRA * 2;
        int temp = 0;
        while (desiredStartSize > 400) //300=291  [330]=292  400=295 500=291
        {
            desiredStartSize = (desiredStartSize >> 1) + 1;
            if (dbug) temp++;
        }
        int curSize = desiredStartSize;

        BigInteger scaledOne2 = (BigInteger.One << ((curSize << 1) + EXTRA * 2));
        BigInteger result = scaledOne2 / (x >> (xLen - curSize - 1 - EXTRA));
        curSize += EXTRA;
        

        if (dbug) Console.WriteLine($"");
        ////////////////////// Newton version  //////////////////////
        const int EXTRA_BITS_TO_REMOVE1 = 1;
        while (curSize <= Math.Min(1024, requestedPrecision)) // When we reach out 1000 bits lets move to NewtonPlus as it is slightly faster.
        {
            int doubleCurSize = (curSize << 1);

            if (dbug) Console.Write($"{(( (double)(curSize << temp) / requestedPrecision) + "     ").Substring(0,4)} [{(curSize << temp) - requestedPrecision}]  ");

            BigInteger scalingFactor = BigInteger.One << (doubleCurSize + 1);
            BigInteger xTimesY = ((x >> (xLen - doubleCurSize)) * result) >> (curSize - 1); // future: we only need the bottom half of this.
            BigInteger twoMinusXy = scalingFactor - xTimesY;
            result = (result * twoMinusXy) >> (curSize + EXTRA_BITS_TO_REMOVE1);

            curSize = doubleCurSize - EXTRA_BITS_TO_REMOVE1;
            if (dbug) temp--;
        }

        // Lets make sure we are 100% accurate at this point.
        const int SKIP_LOWEST = 4;  //3 fails 
        result >>= SKIP_LOWEST;
        // back off until we see both a zero and one
        int reduceBy2 = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : (~result)) + 1; // need one for things like ..100000
        result >>= reduceBy2;
        curSize -= reduceBy2 + SKIP_LOWEST;

        //CheckIfCorrectSoFar(x, xLen, curSize, result);

        // Let's shift into high gear...
        ////////////////////// NewtonPlus version  //////////////////////
        const int EXTRA_BITS_TO_REMOVE2 = 1;
        while (curSize <= requestedPrecision)
        {
            int doubleCurSize = (curSize << 1);

            //if ((double)doubleCurSize / requestedPrecision > 0.9)
            if (dbug) Console.Write($"{(((double)(curSize << temp) / requestedPrecision) + "     ").Substring(0, 4)} [{(curSize << temp) - requestedPrecision}]  ");

            // We need insert our "1" in the middle, we do this by incrementing the upper half with a 1
            result++; // we could just do a add a "(1 << doublecurSize)"
            BigInteger mask22 = (BigInteger.One << (curSize + 1)) - 1;
            BigInteger xTimesY22 = ((x >> (xLen - doubleCurSize)) * result) >> (curSize - 1); // future: we only need the bottom half of this.
            result = ((result << (doubleCurSize)) - (result * (xTimesY22 & mask22))) >> (curSize + EXTRA_BITS_TO_REMOVE2);

            //// back off until we see both a zero and one
            int reduceBy = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : ~result) + 1;
            result >>= reduceBy;

            //CheckIfCorrectSoFar(x, xLen, curSize, result);

            curSize = doubleCurSize - reduceBy - EXTRA_BITS_TO_REMOVE2;
            if (dbug) temp--;
        }

        if (dbug) Console.Write($"{(((double)(curSize << temp) / requestedPrecision) + "     ").Substring(0, 4)} [{(curSize << temp) - requestedPrecision}]  ");

        //if (trailingZeros> 14) Console.Write(trailingZeros);
        BigInteger tempResult = result >> curSize - requestedPrecision;
        return isPos ? tempResult : (-tempResult);

         // Check if correct so far and output info if not
        static void CheckIfCorrectSoFar(BigInteger x, int xLen, int curSize, BigInteger result)
        {
            BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
            int correctBits2 = ToBinaryString(result).Zip(ToBinaryString(checkResult), static (c1, c2) => c1 == c2).TakeWhile(static b => b).Count();
            if (correctBits2 < Math.Min(curSize, checkResult.GetBitLength()))
                Console.WriteLine($"not 100% !!\r\nAns: {ToBinaryString(checkResult)}[{checkResult.GetBitLength()}]\r\nRes: {ToBinaryString(result)}[{result.GetBitLength()}]");
        }
    }


    // simple version just for verification.
    public static BigInteger InverseBigIntegerClassic(BigInteger x, int requestedPrecision = 0)
    {
        int xLen = (int)x.GetBitLength();
        return (BigInteger.One << (xLen + ((requestedPrecision == 0) ? xLen : requestedPrecision) - 1)) / x;
    }


    public static BigInteger InverseBigInteger8(BigInteger x, int requestedPrecision = 0)
    {
        int xLen = (int)x.GetBitLength();
        if (requestedPrecision <= 0)
        {
            if (requestedPrecision < 0)
                throw new DivideByZeroException("'precisionBits' can not be negative.");
            requestedPrecision = xLen;
        }

        bool isPos = x.Sign >= 0;
        if (!isPos)
            x = -x;



        //// Trailing Zeros never matter
        int trailingZeros = (int)BigInteger.TrailingZeroCount(x);
        x >>= trailingZeros;
        xLen -= trailingZeros;

        if (xLen < 65)
        {
            // or if xLen = 33 then requestedPrecision <34
            if (xLen < 33)
            {
                ulong result64 = (1UL << 63) / (ulong)x; // 63 /  31
                result64 >>= 64 - (int)ulong.LeadingZeroCount(result64) - requestedPrecision;
                return isPos ? result64 : (-(BigInteger)result64);
            }
            UInt128 result128 = (UInt128.One << 127) / (ulong)x;
            result128 >>= (int)UInt128.Log2(result128) - requestedPrecision + 1; //what about uint.Log2(res>>32) +32
            return isPos ? result128 : (-(BigInteger)result128);
        }

        if (xLen < 512)
        {
            BigInteger resultBI = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
            return isPos ? resultBI : (-resultBI);
        }

        const bool dbug = false;


        ////////  Get Starting Size  //////// 8-282 7-281 6-285 5-297 4-290 3-293 2-299 1-271
        const int EXTRA = 4;
        int desiredStartSize = requestedPrecision + EXTRA * 2;
        int temp = 0;
        while (desiredStartSize > 400) //300=291  [330]=292  400=295 500=291
        {
            desiredStartSize = (desiredStartSize >> 1) + 1;
            if (dbug) temp++;
        }
        int curSize = desiredStartSize;




        // Option 1: issue with the below as reduceBy2 could fully shrink the result, can be fixed by adding to a loop that makes it larger
        //BigInteger scaledOne2 = (BigInteger.One << ((curSize << 1) + EXTRA * 2));
        //BigInteger result = scaledOne2 / (x >> (xLen - curSize - 1 - EXTRA));
        //int reduceBy2 = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : (~result)) + 1;
        //result >>= reduceBy2;
        //curSize = curSize - reduceBy2 + EXTRA;

        // Option 2: 
        //BigInteger result;
        //while (true)
        //{
        //    BigInteger scaledOne2 = (BigInteger.One << ((curSize << 1) + EXTRA * 2));
        //    result = scaledOne2 / (x >> (xLen - curSize - 1 - EXTRA));
        //    //todo: issue here when 1000000000000000000000000
        //    int reduceBy2 = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : (~result)) + 1;
        //    result >>= reduceBy2;
        //    int newSize = curSize + EXTRA- reduceBy2 ;
        //    if (newSize > 100)
        //    {
        //        curSize = newSize;
        //        break;
        //    }
        //    curSize <<= 1;
        //}

        // Option 3: it does not need to be perfect yet
        BigInteger scaledOne2 = (BigInteger.One << ((curSize << 1) + EXTRA * 2));
        BigInteger result = scaledOne2 / (x >> (xLen - curSize - 1 - EXTRA));
        curSize = curSize + EXTRA;


        if (dbug) Console.WriteLine($"");
        ////////////////////// Newton version  //////////////////////
        const int EXTRA_BITS_TO_REMOVE1 = 1;
        while (curSize <= Math.Min(1024, requestedPrecision)) // When we reach out 1000 bits lets move to NewtonPlus as it is slightly faster.
        {
            int doubleCurSize = (curSize << 1);

            if (dbug) Console.Write($"{(((double)(curSize << temp) / requestedPrecision) + "     ").Substring(0, 4)} [{(curSize << temp) - requestedPrecision}]  ");

            BigInteger scalingFactor = BigInteger.One << (doubleCurSize + 1);
            BigInteger xTimesY = ((x >> (xLen - doubleCurSize)) * result) >> (curSize - 1); // future: we only need the bottom half of this.
            BigInteger twoMinusXy = scalingFactor - xTimesY;
            result = (result * twoMinusXy) >> (curSize + EXTRA_BITS_TO_REMOVE1);

            curSize = doubleCurSize - EXTRA_BITS_TO_REMOVE1;
            if (dbug) temp--;
        }

        // Lets make sure we are 100% accurate at this point.
        const int SKIP_LOWEST = 3;
        result >>= SKIP_LOWEST;
        // back off until we see both a zero and one
        int reduceBy2 = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : (~result)) + 1; // need one for things like ..100000
        result >>= reduceBy2;
        curSize -= reduceBy2 + SKIP_LOWEST;

        ////////////////////// NewtonPlus version  //////////////////////
        const int EXTRA_BITS_TO_REMOVE2 = 1;
        while (curSize <= requestedPrecision)
        {
            int doubleCurSize = (curSize << 1);

            //if ((double)doubleCurSize / requestedPrecision > 0.9)
            if (dbug) Console.Write($"{(((double)(curSize << temp) / requestedPrecision) + "     ").Substring(0, 4)} [{(curSize << temp) - requestedPrecision}]  ");

            // We need insert our "1" in the middle, we do this by incrementing the upper half with a 1
            result++; // we could just do a add a "(1 << doublecurSize)"
            BigInteger mask22 = (BigInteger.One << (curSize + 1)) - 1;
            BigInteger xTimesY22 = ((x >> (xLen - doubleCurSize)) * result) >> (curSize - 1); // future: we only need the bottom half of this.
            result = ((result << (doubleCurSize)) - (result * (xTimesY22 & mask22))) >> (curSize + EXTRA_BITS_TO_REMOVE2);

            //// back off until we see both a zero and one
            int reduceBy = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : ~result) + 1;
            result >>= reduceBy;


            //// Check if correct so far and output info if not
            //BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
            //int correctBits2 = ToBinaryString(result).Zip(ToBinaryString(checkResult), static (c1, c2) => c1 == c2).TakeWhile(static b => b).Count();
            //if (correctBits2 < Math.Min(curSize, checkResult.GetBitLength()))
            //    Console.WriteLine($"not 100% !!\r\nAns: {ToBinaryString(checkResult)}[{checkResult.GetBitLength()}]\r\nRes: {ToBinaryString(result)}[{result.GetBitLength()}]");

            curSize = doubleCurSize - reduceBy - EXTRA_BITS_TO_REMOVE2;
            if (dbug) temp--;

        }

        if (dbug) Console.Write($"{(((double)(curSize << temp) / requestedPrecision) + "     ").Substring(0, 4)} [{(curSize << temp) - requestedPrecision}]  ");


        //if (trailingZeros> 14) Console.Write(trailingZeros);
        BigInteger tempResult = result >> curSize - requestedPrecision;
        return isPos ? tempResult : (-tempResult);
    }






    public static BigInteger InverseBigInteger7(BigInteger x, int requestedPrecision)
    {
        int xLen = (int)x.GetBitLength();
        if (requestedPrecision > xLen)
        {
            throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
        }

        bool isPos = x.Sign >= 0;
        if (!isPos)
            x = -x;

        if (xLen < 65)
        {
            if (xLen < 33)
            {
                ulong result64 = (1UL << 63) / (ulong)x; // 63 /  31
                result64 >>= 64 - (int)ulong.LeadingZeroCount(result64) - requestedPrecision;
                return isPos ? result64 : (-(BigInteger)result64);
            }
            UInt128 result128 = (UInt128.One << 127) / (ulong)x;
            result128 >>= (int)UInt128.Log2(result128) - requestedPrecision + 1; //what about uint.Log2(res>>32) +32
            return isPos ? result128 : (-(BigInteger)result128);
        }

        if (xLen < 512)
        {
            BigInteger resultBI = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
            return isPos ? resultBI : (-resultBI);
        }

        ////////  Get Starting Size  ////////
        const int EXTRA = 8;
        int desiredStartSize = requestedPrecision + EXTRA * 2;
        while (desiredStartSize > 330)
            desiredStartSize = (desiredStartSize >> 1) + 1;

        BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + EXTRA * 2));
        BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - EXTRA));

        int reduceBy2 = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : (~result)) + 1;
        result >>= reduceBy2;

        desiredStartSize = desiredStartSize - reduceBy2 + EXTRA;

        ////////////////////// Newton version  //////////////////////
        int EXTRA_BITS_TO_REMOVE = 1;
        while (desiredStartSize <= requestedPrecision)
        {
            int doubleDesiredStartSize = (desiredStartSize << 1);

            BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
            BigInteger xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1); // future: we only need the bottom half of this.
            BigInteger twoMinusXy = scalingFactor - xTimesY;
            result = (result * twoMinusXy) >> (desiredStartSize + EXTRA_BITS_TO_REMOVE);

            int reduceBy = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : (~result)) + 1; // need one for things like ..100000
            result >>= reduceBy;

            desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;

            // When we reach out 1000 bits lets move to NewtonPlus as it is slightly faster.
            if (desiredStartSize > 1024)
                break;
        }

        ////////////////////// NewtonPlus version  //////////////////////
        EXTRA_BITS_TO_REMOVE = 1;
        while (desiredStartSize <= requestedPrecision)
        {
            int doubleDesiredStartSize = (desiredStartSize << 1);

            // We need insert our "1" in the middle, we do this by incrementing the upper half with a 1
            result++; // we could just do a add a "(1 << doubleDesiredStartSize)"
            BigInteger mask22 = (BigInteger.One << (desiredStartSize + 1)) - 1;
            BigInteger xTimesY22 = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1); // future: we only need the bottom half of this.
            result = ((result << (doubleDesiredStartSize)) - (result * (xTimesY22 & mask22))) >> (desiredStartSize + EXTRA_BITS_TO_REMOVE);

            //// back off until we see both a zero and one
            int reduceBy = (int)BigInteger.TrailingZeroCount(result.IsEven ? result : ~result) + 1;
            result >>= reduceBy;

            // Check if correct so far and output info if not
            BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
            int correctBits2 = ToBinaryString(result).Zip(ToBinaryString(checkResult), static (c1, c2) => c1 == c2).TakeWhile(static b => b).Count();
            if (correctBits2 < Math.Min(requestedPrecision, doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE))
                Console.WriteLine($"not 100% !!\r\nAns: {ToBinaryString(checkResult)}[{checkResult.GetBitLength()}]\r\nRes: {ToBinaryString(result)}[{result.GetBitLength()}]");

            desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;
        }

        BigInteger tempResult = result >> desiredStartSize - requestedPrecision;
        return isPos ? tempResult : (-tempResult);
    }


    /// <summary>
    /// A high performance BigInteger to binary string converter
    /// that supports 0 and negative numbers.
    /// License: MIT / Created by Ryan Scott White, 7/16/2022;
    /// https://stackoverflow.com/a/73009264/2352507
    /// </summary>
    public static string ToBinaryString3(BigInteger x)
    {
        // Setup source
        ReadOnlySpan<byte> srcBytes = x.ToByteArray();
        int srcLoc = srcBytes.Length - 1;

        // Find the first bit set in the first byte so we don't print extra zeros.
        int msb = BitOperations.Log2(srcBytes[srcLoc]);

        // Setup Target
        Span<char> dstBytes = stackalloc char[srcLoc * 8 + msb + 2];
        int dstLoc = 0;

        // Add leading '-' sign if negative.
        if (x.Sign < 0)
        {
            dstBytes[dstLoc++] = '-';
        }
        //else if (!x.IsZero) dstBytes[dstLoc++] = '0'; // add adding leading '0' (optional)

        // The first byte is special because we don't want to print leading zeros.
        byte b = srcBytes[srcLoc--];
        for (int j = msb; j >= 0; j--)
        {
            dstBytes[dstLoc++] = (char)('0' + ((b >> j) & 1));
        }

        // Add the remaining bits.
        for (; srcLoc >= 0; srcLoc--)
        {
            byte b2 = srcBytes[srcLoc];
            for (int j = 7; j >= 0; j--)
            {
                dstBytes[dstLoc++] = (char)('0' + ((b2 >> j) & 1));
            }
        }

        return dstBytes.ToString();
    }






// below is as of 12/10/2024
public static BigInteger InverseBigIntegerClassicNewton(BigInteger x, int requestedPrecision)
{
	int xLen = (int)x.GetBitLength();
	if (requestedPrecision > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}

	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - requestedPrecision;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - requestedPrecision + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
		return res;
	}

	////////  Get Starting Size  ////////
	const int EXTRA = 8;
	int desiredStartSize = requestedPrecision + EXTRA * 2;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 330)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}

	BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + EXTRA * 2));
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - EXTRA));

	int reduceBy2 = (int)BigInteger.TrailingZeroCount((result.IsEven) ? result : (~result)) + 1; // need one for things like ..100000
	result >>= reduceBy2;

	desiredStartSize = desiredStartSize - reduceBy2 + EXTRA; 


	int EXTRA_BITS_TO_REMOVE = 1;// 3;
	while (desiredStartSize <= requestedPrecision)
	{
		numOfNewtonSteps--;
		int doubleDesiredStartSize = (desiredStartSize << 1);

		// Newton version
		BigInteger xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1);
		BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
		BigInteger twoMinusXy = scalingFactor - xTimesY;
		result = (result * twoMinusXy) >> (desiredStartSize + EXTRA_BITS_TO_REMOVE);

		//// back off until we see both a zero and one??
		int reduceBy = (int)BigInteger.TrailingZeroCount((result.IsEven) ? result : (~result)) + 1; // need one for things like ..100000
		result >>= reduceBy;

		desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;
	}


	BigInteger tempResult = result >> desiredStartSize - requestedPrecision;

	return tempResult;

}

public static BigInteger InverseBigInteger(BigInteger x, int requestedPrecision)
{
	int xLen = (int)x.GetBitLength();
	if (requestedPrecision > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}

	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - requestedPrecision;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - requestedPrecision + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
		return res;
	}

	////////  Get Starting Size  ////////
	const int EXTRA = 8;
	int desiredStartSize = requestedPrecision + EXTRA*2;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 330)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}

	BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + EXTRA*2));
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - EXTRA));

	//result >>= 2;

	int reduceBy2 = (int)BigInteger.TrailingZeroCount((result.IsEven) ? result : (~result)) + 1; // need one for things like ..100000
	result >>= reduceBy2;

	//int lastBits = (byte)(result & 0xFF);
	//if (lastBits == 0)
	//{
	//    // possible to high
	//    scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + EXTRA * 4));
	//    result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - EXTRA * 2));
	//    lastBits = (ushort)(result & 0xFFFF);
	//    if (lastBits == 0)
	//    {
	//        // more checking here
	//    }
	//    result >>= EXTRA * 2;
	//}
	//else
	//{
	//    result >>= EXTRA;
	//}

	// desiredStartSize = (int)result.GetBitLength();

	// Benchmarks and timings
	// Bits: 1202 -> 1.46/48/46    51/51/52   
	// Extra Size to 7  ->  1.51/46/52/46  (put back)
	// 325 -> 350           1.50,51,51
	// 325 -> 300           1.50,47,45
	// 325 -> 330           1.50,52,50     (keep)
	// .net 9               1.32,38,39     (keep - since we need to anyway)
	//                      1.36,42,40,43,35,38,31
	// 39 34 32 36  34 36 30
	desiredStartSize = desiredStartSize - reduceBy2 + EXTRA; //(int)result.GetBitLength();
	//desiredStartSize = (int)result.GetBitLength();
	//BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
	//int orgCorrectBits = ToBinaryString(result).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	////int cResLen = (int)checkResult.GetBitLength();
	////int correctBits = ToolsForOther.ToBinaryString(checkResult).Zip(ToolsForOther.ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	////Console.WriteLine($"Ans:   {ToBinaryShades(checkResult)} [{checkResult.GetBitLength()}]");
	////Console.WriteLine($"result:{ToBinaryShades(result)} [{resLen}] (correct:{orgCorrectBits} of {resLen}) LastBits:{Convert.ToString(lastBits, 2)}");
	//if (orgCorrectBits != resLen)
	//    Console.WriteLine($"result:{ToBinaryShades(result)} [{resLen}] FAIL!!!!!!!!! (correct:{orgCorrectBits} of {resLen})");


	int EXTRA_BITS_TO_REMOVE = 1;// 3;
	while (desiredStartSize <= requestedPrecision)
	{
		numOfNewtonSteps--;
		int doubleDesiredStartSize = (desiredStartSize << 1);


		if (desiredStartSize > 1000)
		{
			////////////////////// Newton version  //////////////////////
			BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
			BigInteger twoMinusXy = scalingFactor - xTimesY;
			result = (result * twoMinusXy) >> (desiredStartSize + EXTRA_BITS_TO_REMOVE);
		}
		else
		{
			////////////////////// NewtonPlus version  //////////////////////
			result++;
			BigInteger mask22 = (BigInteger.One << (desiredStartSize + 1)) - 1;
			BigInteger xTimesY22 = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1); // future: we only need the bottom half of this.
			result = ((result << (doubleDesiredStartSize)) - (result * (xTimesY22 & mask22))) >> (desiredStartSize + EXTRA_BITS_TO_REMOVE);
		}

		//result >>= EXTRA_BITS_TO_REMOVE;


		//// Check if correct so far and output info if not
		//int correctBits2 = ToBinaryString(result).Zip(ToBinaryString(checkResult), static (c1, c2) => c1 == c2).TakeWhile(static b => b).Count();
		//if (correctBits2 < Math.Min(requestedPrecision, doubleDesiredStartSize /*- reduceBy*/ - EXTRA_BITS_TO_REMOVE))
		//{
		//    //Console.WriteLine($"not 100% !!\r\nAns: {ToBinaryString(checkResult)}[{checkResult.GetBitLength()}]\r\nRes: {ToBinaryString(result)}[{result.GetBitLength()}]");
		//}


		// Benchmarks 32 30 45 41 39
		//// back off until we see both a zero and one??
		int reduceBy = (int)BigInteger.TrailingZeroCount((result.IsEven) ? result : (~result)) + 1; // need one for things like ..100000
		result >>= reduceBy;

		// Benchmarks 29 27 35 33
		// Fast but might have issue with lots of zeros
		//UInt64 tempVal = (UInt64)(0xFFFFFFFF & result);
		//int reduceBy = (int)UInt64.TrailingZeroCount(((tempVal & 0x1) == 0) ? tempVal : (~tempVal)) + 1; // need one for things like ..100000
		//// if (reduceBy > 62) do full
		//result >>= reduceBy;

		// Benchmarks 30 36 30
		//int reduceBy = 1;
		//if (result.IsEven)
		//{
		//    while ((result >> reduceBy).IsEven) reduceBy++;
		//}
		//else
		//{
		//    while (!(result >> reduceBy).IsEven) reduceBy++;
		//}
		//reduceBy++;
		//result >>= reduceBy;


		//int reduceBy;
		//int tempVal = (int)(0xF & result);
		//if (tempVal != 0 || tempVal != 0xF)
		//{
		//    result >>= 4;
		//    reduceBy = 4;
		//}
		//else
		//{
		//    tempVal = (int)(0xFF & result);
		//    if (tempVal != 0 || tempVal != 0xF)
		//        result >>= 8;
		//    reduceBy = 8;
		//}

		desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;

		//if (desiredStartSize != result.GetBitLength()) Console.WriteLine($"SIZE FAIL: {desiredStartSize} != {result.GetBitLength()}");
	}


	BigInteger tempResult = result >> desiredStartSize - requestedPrecision;
	//int correctBits = ToBinaryString(tempResult).Zip(ToBinaryString(checkResult), static (c1, c2) => c1 == c2).TakeWhile(static b => b).Count();
	////BigInteger resultT = prod2 >> (requestedPrecision - doubleDesiredStartSize + EXTRA_BITS_TO_REMOVE);
	////Console.WriteLine($"Result:{ToBinaryShades(resultT)} [{resultT.GetBitLength()}]");
	////Console.WriteLine($"xTimesY22:{(xTimesY22 >> (desiredStartSize - 8)).GetBitLength()}[{xTimesY22.GetBitLength()}] desiredStartSize:{desiredStartSize} xTimesY22:{ToBinaryString(/*0x3FF &*/ (xTimesY22 >> (desiredStartSize - 0)), 1)} {ToBinaryString(0xFFFF & (xTimesY22 >> (desiredStartSize)), 1)} botOfRes:{ToBinaryString(result2>>((int)result2.GetBitLength()-8), 8)}...{ToBinaryString(0xFF & result2, 8)}"); //{ToBinaryString(prod1)} {prod1}

	//if (checkResult != tempResult)
	//{
	//    Console.WriteLine($"FAIL!!!! correctBits:{correctBits} of {desiredStartSize}");
	//    Console.WriteLine($"Ans: {ToBinaryString(checkResult)}\r\nRes: {ToBinaryString(result)}");
	//    if (tempResult.GetBitLength() != requestedPrecision)
	//    {
	//        Console.WriteLine($"!!!! incorrect length resultLen:{tempResult.GetBitLength()} xLen:{xLen}  (miss by {tempResult.GetBitLength() - xLen})"); //{ToBinaryString(prod1)} {prod1}
	//    }
	//    else
	//    {
	//        Console.WriteLine($"fail\r\nAns: {ToBinaryString(checkResult)}\r\nRes: {ToBinaryString(tempResult)}");
	//    }
	//}
	return tempResult;
	
}

public static BigInteger InverseBigInteger7(BigInteger x, int requestedPrecision)
{

	int xLen = (int)x.GetBitLength();
	if (requestedPrecision > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}

	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - requestedPrecision;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - requestedPrecision + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
		return res;
	}


	////////  Get Starting Size  ////////
	//int numOfNewtonSteps = BitOperations.Log2((uint)(wantedPrecision / size)) + 2;
	//int wantedSize = (wantedPrecision >> numOfNewtonSteps) + 2;

	int desiredStartSize = requestedPrecision + 16;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 325)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}
	int startedSteps = numOfNewtonSteps;

	BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + 16));
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - 8));

	int lastBits = (byte)(result & 0xFF);
	if (lastBits == 0)
	{
		// possible to high
		scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + 32));
		result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - 16));
		lastBits = (ushort)(result & 0xFFFF);
		if (lastBits == 0)
		{
			// more checking here
		}
		result >>= 16;
	}
	else
	{
		result >>= 8;
	}

	// desiredStartSize = (int)result.GetBitLength();



	int resLen = (int)result.GetBitLength();
	BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
	int orgCorrectBits = ToBinaryString(result).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	//int cResLen = (int)checkResult.GetBitLength();
	//int correctBits = ToolsForOther.ToBinaryString(checkResult).Zip(ToolsForOther.ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	//Console.WriteLine($"Ans:   {ToBinaryShades(checkResult)} [{checkResult.GetBitLength()}]");
	//Console.WriteLine($"result:{ToBinaryShades(result)} [{resLen}] (correct:{orgCorrectBits} of {resLen}) LastBits:{Convert.ToString(lastBits, 2)}");
	if (orgCorrectBits != resLen)
		Console.WriteLine($"result:{ToBinaryShades(result)} [{resLen}] FAIL!!!!!!!!! (correct:{orgCorrectBits} of {resLen})");


	int EXTRA_BITS_TO_REMOVE = 1;// 3;
	while (true)
	{
		numOfNewtonSteps--;
		int doubleDesiredStartSize = (desiredStartSize << 1);
		BigInteger xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1);

		{ // NewtonPlus version
			BigInteger result2 = result + 1;
			BigInteger mask22 = (BigInteger.One << (desiredStartSize + 1)) - 1;
			BigInteger xTimesY22 = ((x >> (xLen - doubleDesiredStartSize)) * result2) >> (desiredStartSize - 1); // future: we only need the bottom half of this.
			result = ((result2 << (doubleDesiredStartSize)) - (result2 * (xTimesY22 & mask22))) >> desiredStartSize;
		}


		if (false)
		{
			bool firstDisplay = true;
			int checkResultSize = (int)checkResult.GetBitLength();
			int end = 4; int fails = 0; int found = 0;
			BigInteger prod2 = 0;
			for (int i = 0; i <= end; i = (i == 0) ? 1 : (i > 0 ? -i : -i + 1))
				for (int j = 0; j <= end; j = (j == 0) ? 1 : (j > 0 ? -j : -j + 1))
					for (int k = 0; k <= end; k = (k == 0) ? 1 : (k > 0 ? -k : -k + 1))
						for (int m = 0; m <= end; m = (m == 0) ? 1 : (m > 0 ? -m : -m + 1))
							for (int n = 0; n <= end; n = (n == 0) ? 1 : (n > 0 ? -n : -n + 1))
								for (int p = 0; p <= end; p = (p == 0) ? 1 : (p > 0 ? -p : -p + 1))
								{
									int preSum = Math.Abs(i) + Math.Abs(j) + Math.Abs(k) + Math.Abs(m) + Math.Abs(n) + Math.Abs(p);
									if (preSum > end) continue;
									for (int q = 0; q <= end; q = (q == 0) ? 1 : (q > 0 ? -q : -q + 1))
										for (int r = 0; r <= end; r = (r == 0) ? 1 : (r > 0 ? -r : -r + 1))
											for (int s = 0; s <= end; s = (s == 0) ? 1 : (s > 0 ? -s : -s + 1))
												for (int t = 0; t <= end; t = (t == 0) ? 1 : (t > 0 ? -t : -t + 1))
													for (int u = 1; u <= end; u = (u == 0) ? 1 : (u > 0 ? -u : -u + 1))
														for (int v = 0; v <= end; v = (v == 0) ? 1 : (v > 0 ? -v : -v + 1))
															for (int w = 0; w <= end; w = (w == 0) ? 1 : (w > 0 ? -w : -w + 1))
																for (int y = 0; y <= end; y = (y == 0) ? 1 : (y > 0 ? -y : -y + 1))
																{   /*int w = 1;*/
																	int changeSum = preSum + Math.Abs(q - 1) + Math.Abs(r) + Math.Abs(s) + Math.Abs(t) + Math.Abs(u - 1) + Math.Abs(v) + Math.Abs(w - 1);
																	if (Math.Abs(u) == 0 /*|| (Math.Abs(v) == 0) */ || changeSum > end)
																		continue;
																	BigInteger result2 = (result >> v) + w;
																	BigInteger mask22 = (BigInteger.One << (desiredStartSize + i)) - 1;
																	BigInteger xTimesY22 = (((x >> (xLen - doubleDesiredStartSize + j)) + r) * (result2 + k)) >> (desiredStartSize - 1 + m);
																	prod2 = ((result2 + q) << (doubleDesiredStartSize + t)) - u * ((result2 + n) * (((xTimesY22 + s) & mask22) - p));

																	// Check Result
																	int bitsToHide = 0;
																	int prod2Size = (int)prod2.GetBitLength();
																	BigInteger checkResult2 = 0;
																	if (checkResultSize > prod2Size)
																	{
																		checkResult2 = checkResult >> (checkResultSize + bitsToHide - prod2Size);
																		prod2 >>= bitsToHide;
																	}
																	else
																	{
																		checkResult2 = checkResult >> bitsToHide;
																		prod2 >>= (prod2Size + bitsToHide - checkResultSize);
																	}

																	//prod1b |= mask2;
																	//prod2  |= mask2;
																	//Console.WriteLine($"Mask:{ToBinaryString(mask2)}");

																	if (checkResult2 >> 5 == prod2 >> 5)// || (prod1>>1) == prod2 || prod1 == (prod2>>1) || (prod1 >> 1) == (prod2 >> 1) || (prod1 >> 2) == prod2 || prod1 == (prod2 >> 2) || (prod1 >> 2) == (prod2 >> 2))
																	{
																		//Console.WriteLine($"match: {fails} {ToBinaryString(prod1)}");
																		if (firstDisplay == true)
																			Console.WriteLine($"Sum	i	j	k	m	n	p	q	r	s	t	u	v	w");
																		else
																			Console.WriteLine($"{changeSum,2}	{i,2}	{j,2}	{k,2}	{m,2}	{n,2}	{p,2}	{q,2}	{r,2}	{s,2}	{t,2}	{u,2}	{v,2}	{w,2}");
																		found++; firstDisplay = false;
																		//Console.WriteLine($"prod1: {ToBinaryString(prod1b)}");
																		//Console.WriteLine($"prod2: {ToBinaryString(prod2)}");
																		//goto doneWithScan;
																		//if (found > 4)
																		//{ goto skippp; }
																	}
																	else
																	{
																		////Console.WriteLine($"{ToBinaryString(result)}|{ToBinaryString((BigInteger.One << doubleDesiredStartSize) - ((result + adj) * ((xTimesY & mask) - 0)))}");
																		//if (fails == 0)
																		//{
																		//    Console.WriteLine($"prod1: {ToBinaryString(prod1b)}");
																		//    Console.WriteLine($"prod2: {ToBinaryString(prod2)}");
																		//    //Console.WriteLine($"{x}");
																		//    //Console.WriteLine($"{ToBinaryString(x)}");
																		//                                                //Console.WriteLine($"{ToBinaryString(prod1b-prod2)}");
																		//                                            }
																		//fails++;
																	}
																}
								}
							//if (found <4)
							//{ }

							skippp:
			if (numOfNewtonSteps == 0)
				return prod2 >> (doubleDesiredStartSize - requestedPrecision);
			//Console.WriteLine($"{(found? "match" : "miss")}: [{fails}]"); //{ToBinaryString(prod1)} {prod1}
		}


		// Are we done? 
		//   If yes, Check if correct?

		//   If no, Check if first n bits are correct.


		//Console.WriteLine($"Ans: {ToBinaryString(checkResult)}\r\nRes: {ToBinaryString(result)}");

		BigInteger tempResult = result >> doubleDesiredStartSize - requestedPrecision;
		int score = ToBinaryString(tempResult).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
		//BigInteger resultT = prod2 >> (requestedPrecision - doubleDesiredStartSize + EXTRA_BITS_TO_REMOVE);
		//Console.WriteLine($"Result:{ToBinaryShades(resultT)} [{resultT.GetBitLength()}]");
		//Console.WriteLine($"xTimesY22:{(xTimesY22 >> (desiredStartSize - 8)).GetBitLength()}[{xTimesY22.GetBitLength()}] desiredStartSize:{desiredStartSize} xTimesY22:{ToBinaryString(/*0x3FF &*/ (xTimesY22 >> (desiredStartSize - 0)), 1)} {ToBinaryString(0xFFFF & (xTimesY22 >> (desiredStartSize)), 1)} botOfRes:{ToBinaryString(result2>>((int)result2.GetBitLength()-8), 8)}...{ToBinaryString(0xFF & result2, 8)}"); //{ToBinaryString(prod1)} {prod1}

		if (numOfNewtonSteps == 0)
		{
			if (checkResult == tempResult)
			{
				//Console.WriteLine($"match correctBits:{score} of {xLen}"); //{ToBinaryString(prod1)} {prod1}
			}
			else
			{
				if (tempResult.GetBitLength() != requestedPrecision)
					Console.WriteLine($"incorrect Length:result[{tempResult.GetBitLength()}] of xLen:{xLen}  (miss by {tempResult.GetBitLength() - xLen}) correctBits:{score}"); //{ToBinaryString(prod1)} {prod1}
				else
				{
					Console.WriteLine($"fail\r\nAns: {ToBinaryString(checkResult)}\r\nRes: {ToBinaryString(tempResult)}");
				}
			}
			return tempResult;
		}

		result >>= EXTRA_BITS_TO_REMOVE;


		// back off until we see both a zero and one??
		int reduceBy = 0;
		if (result.IsEven)
			reduceBy = (int)BigInteger.TrailingZeroCount(result) + 1;
		else
			reduceBy = (int)BigInteger.TrailingZeroCount(~result) + 1;  //todo: need to check more then just 64 bits! (also, a loop might be faster going bit by bit)

		//Console.WriteLine($"Ans_Bits:{ToBinaryShades((checkResult >> ((int)checkResult.GetBitLength() - (int)result.GetBitLength())) & 0xFFF),14}");
		//Console.WriteLine($"LastBits:{ToBinaryShades(result & 0xFFF, 14)} >> {reduceBy}");
		//Console.WriteLine($"LastBits:{ToBinaryShades(~result & 0xFFF, 14)}");

		if (desiredStartSize > 600)
		{ }

		if (desiredStartSize > xLen)
		{
			result >>= (desiredStartSize - xLen);
			if (checkResult == result >> (desiredStartSize - xLen))
			{
				Console.WriteLine($"match and {desiredStartSize} > {xLen} "); //{ToBinaryString(prod1)} {prod1}
				if (numOfNewtonSteps == 0)
					return result;
			}
			else
			{
				if (result.GetBitLength() != xLen)
					Console.WriteLine($"incorrect Length:prod2[{result.GetBitLength()}] of xLen:{xLen}  (miss by {result.GetBitLength() - xLen})"); //{ToBinaryString(prod1)} {prod1}
				else
					Console.WriteLine($"fail {xLen}");
			}
		}
		else
		{
			result >>= reduceBy;
			desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;
		}
	}
}

public static BigInteger InverseBigInteger6(BigInteger x, int precisionBits)
{

	int xLen = (int)x.GetBitLength();
	if (precisionBits > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}


	//if (x.IsZero) // not needed since code below throws error
	//    throw new DivideByZeroException("Cannot compute the inverse of zero.");
	 
	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	//if (x.GetBitLength() != precisionBits)
	//    throw new DivideByZeroException("TEST ERROR");

	//if (precisionBits < 53)
	//    return (BigInteger)(((double)(UInt128.One << (2 * precisionBits - 1))) / (double)x);

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - precisionBits;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - precisionBits + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + precisionBits - 1)) / x;
		//if ((int)BigInteger.Log2(res) + 1 != precisionBits)
		//{
		//    Console.WriteLine("XXXXXX");
		//}
		//res >>= ((int)BigInteger.Log2(res) + 1 - precisionBits);
		return res;
	}
	 

	//if (xLen < 128)
	//{
	//    int desiredStartSize2 = precisionBits + 10;
	//    while (desiredStartSize2 > 64)
	//        desiredStartSize2 = ((desiredStartSize2) >> 1) + 1;

	//    UInt128 res = (UInt128.One << 127) / (ulong)(x >> (xLen - 64 + 1));
	//    BigInteger result2 = res >> ((int)UInt128.Log2(res) - desiredStartSize2 + 1); //we know UInt128.Log2(res) is 64?

	//    //BigInteger scaledOne3 = BigInteger.One << ((desiredStartSize2 << 1) + 0);
	//    //BigInteger result2 = (scaledOne3 / (x >> (xLen - desiredStartSize2 - 0 - 1)));

	//    //if (result2 != result3)
	//    //{ }
	//    //else
	//    //{ } 

	//    BigInteger scalingFactor = BigInteger.One << ((desiredStartSize2 << 1) + 1);
	//    BigInteger xTimesY = ((x >> (xLen - (desiredStartSize2 << 1))) * result2) >> (desiredStartSize2 - 1);
	//    BigInteger twoMinusXy = scalingFactor - xTimesY;
	//    result2 = (result2 * twoMinusXy) >> desiredStartSize2;
	//    desiredStartSize2 <<= 1;

	//    //if ((int)result.GetBitLength() != doubleDesiredStartSize)  { }
	//    result2 >>= ((desiredStartSize2) - precisionBits);

	//    return (isPos) ? result2 : -result2;
	//}

	//int bytes = x.GetByteCount();


	//if (x.IsPowerOfTwo)
	//    return x.Sign * BigInteger.One << (precisionBits - 1);


	//const int ExtraPrecision = 4;
	//if (precisionBits <= UseSimpleForSizesUnder)
	//{
	//    // Lets pre-scale x and just do simple BigInteger integer division
	//    BigInteger scaledOne = BigInteger.One << ((precisionBits << 1) + ExtraPrecision);
	//    return scaledOne / (x >> (xLen - precisionBits - ExtraPrecision - 1));
	//}

	////////  Get Starting Size  ////////
	//int numOfNewtonSteps = BitOperations.Log2((uint)(wantedPrecision / size)) + 2;
	//int wantedSize = (wantedPrecision >> numOfNewtonSteps) + 2;

	int desiredStartSize = precisionBits + 16;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 325)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}
	int startedSteps = numOfNewtonSteps;

	//int desiredStartSize2 = precisionBits + 16;
	//int numOfNewtonSteps = BitOperations.Log2((uint)((desiredStartSize2)a / 325)) + 1;
	//int desiredStartSize = (desiredStartSize2 >> numOfNewtonSteps) + 2;


	//BigInteger scaledOne2 = (BigInteger.One << (desiredStartSize << 1));
	//BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1));
	BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + 16));
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 -8));

	int lastBits = (byte)(result & 0xFF);
	if (lastBits == 0)
	{
		// possible to high
		scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + 32));
		result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - 16));
		lastBits = (UInt16)(result & 0xFFFF);
		if (lastBits == 0)
		{

		}
		// back off until we see both a zero and one??
		result >>= 16;

	}
	else if (lastBits == 255)
	{
		// possible to high
		result >>= 8;
	}
	else
	{
		result >>= 8;
	}

	//result >>= 30;

	//BigInteger test = x * result;
	//Console.WriteLine($"test:{ToBinaryString(test)} [{test.GetBitLength()}]");

	// check result - maybe an issue with starting "result" not being accurate?

	int resLen = (int)result.GetBitLength();
	BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
	//int cResLen = (int)checkResult.GetBitLength();
	//int correctBits = ToolsForOther.ToBinaryString(checkResult).Zip(ToolsForOther.ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	Console.WriteLine($"Ans:   {ToBinaryShades(checkResult)} [{checkResult.GetBitLength()}]");
	Console.WriteLine($"result:{ToBinaryShades(result)} [{result.GetBitLength()}]");

	int EXTRA_BITS_TO_REMOVE = 1;// 3;
	while (true)
	{
		numOfNewtonSteps--;
		//x = BigInteger.Parse("202093266059557925115266673399374673120617825428395545383299518550312490481423064232700602696581628212776090250332862778427463835814523593722050099003906655602355295662034260835350794263619979624501976232828646123677039779210979798544515");
		int doubleDesiredStartSize = (desiredStartSize << 1);
		BigInteger xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1);


		//// Newton version
		//{
		//    BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
		//    BigInteger twoMinusXy = scalingFactor - xTimesY;
		//    BigInteger prod1 = (result * twoMinusXy) >> desiredStartSize;
		//    Console.WriteLine($"prod1: {ToBinaryString(prod1)} [{prod1.GetBitLength()}]");
		//    if (numOfNewtonSteps == 0)
		//    {
		//        prod1 >>= (doubleDesiredStartSize - precisionBits);
		//        int correctBits = ToBinaryString(prod1).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
		//        if (checkResult >> 5 == prod1 >> 5)
		//            Console.WriteLine($"match Correct:{correctBits}");
		//        else
		//            Console.WriteLine($"fail Correct:{correctBits}");

		//        return prod1;
		//    }
		//} 



		// NewtonPlus version
		{
			//if (doubleDesiredStartSize == xTimesY.GetBitLength())  // if 111111111111111111111111010100011... (should be 1000000000000000000010100011...)
			//    result >>= 1;
			
			//BigInteger mask = (BigInteger.One << desiredStartSize) - 1;
			//BigInteger prod2 = ((result << doubleDesiredStartSize) - (result * (xTimesY & mask))) >> desiredStartSize;
			//Console.WriteLine($"     : {ToBinaryString((result << doubleDesiredStartSize))}");
			//Console.WriteLine($"-    : {ToBinaryString((result * (xTimesY & mask)))}");
			//Console.WriteLine($"prod2: {ToBinaryString(prod2)} [{prod2.GetBitLength()}]");


			int[] ii = new int[4], tt = new int[4], vv = new int[4]; // u=1, q=1, w=1
			ii[0] = 1; tt[0] = 0; vv[0] = 0; //  E(option 1)
			ii[1] = 0; tt[1] =-1; vv[1] = 0; //  B
			ii[2] = 1; tt[2]= -1; vv[2] = 0; //  B1
			//ii[3] = 0; tt[3]=  0; vv[3] = -1; //  C  (not very common)
			ii[3] = 0; tt[3]=  0; vv[3] = 0; //  C  (not very common)
			BigInteger prod2 = 0;
			int bestScore = 0; int bestIndex = 0; BigInteger bestResult = 0;
			for (int i = 0; i < vv.Length; i++)
			{
				BigInteger result2 = (result >> vv[i]) + 1;
				BigInteger mask22 = (BigInteger.One << (desiredStartSize + ii[i])) - 1;
				BigInteger xTimesY22 = (((x >> (xLen - doubleDesiredStartSize))) * (result2)) >> (desiredStartSize - 1);
				prod2 = ((result2) << (doubleDesiredStartSize + tt[i])) - ((result2) * (((xTimesY22) & mask22)));

				prod2 >>= (doubleDesiredStartSize - precisionBits);
				prod2 >>= desiredStartSize + tt[i];
				int score = ToBinaryString(prod2).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();

				if (score > bestScore)
				{
					bestScore = score;
					bestResult = prod2;
					bestIndex = i;
				}

				BigInteger resultT = prod2 >> (precisionBits - doubleDesiredStartSize + EXTRA_BITS_TO_REMOVE);
				Console.WriteLine($"Result:{ToBinaryShades(resultT)} [{resultT.GetBitLength()}]");

				if (numOfNewtonSteps == 0)
					if (checkResult >> 5 == prod2 >> 5)
					{
						Console.WriteLine($"match correctBits:{score} of {xLen} using {i}"); //{ToBinaryString(prod1)} {prod1}
						if (numOfNewtonSteps == 0)
							return prod2;
					}
					else
					{
						if (prod2.GetBitLength() != xLen)
							Console.WriteLine($"incorrect Length:prod2[{prod2.GetBitLength()}] of xLen:{xLen}  (miss by {prod2.GetBitLength() - xLen}) correctBits:{score}"); //{ToBinaryString(prod1)} {prod1}
						else
							Console.WriteLine($"fail correctBits:{score} of {xLen}");
					}
				else  // numOfNewtonSteps > 0
				{

				}
			}
			result = bestResult;
		}




		Console.WriteLine($"Result:{ToBinaryShades(result)} [{result.GetBitLength()}]");
		//desiredStartSize = doubleDesiredStartSize - EXTRA_BITS_TO_REMOVE;
		//numOfNewtonSteps--;
		//doubleDesiredStartSize = (desiredStartSize << 1);
		//xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1);


		// NewtonPlus (scan for working) 
		if (false)
		{ 
			bool firstDisplay = true;
			int checkResultSize = (int)checkResult.GetBitLength();
			int end = 4; int fails = 0; int found = 0;
			BigInteger prod2 = 0;
			for (int i = 0; i <= end; i = (i == 0) ? 1 : (i > 0 ? -i : -i + 1))
			for (int j = 0; j <= end; j = (j == 0) ? 1 : (j > 0 ? -j : -j + 1))
			for (int k = 0; k <= end; k = (k == 0) ? 1 : (k > 0 ? -k : -k + 1))
			for (int m = 0; m <= end; m = (m == 0) ? 1 : (m > 0 ? -m : -m + 1))
			for (int n = 0; n <= end; n = (n == 0) ? 1 : (n > 0 ? -n : -n + 1))
			for (int p = 0; p <= end; p = (p == 0) ? 1 : (p > 0 ? -p : -p + 1))
			{    int preSum = Math.Abs(i) + Math.Abs(j) + Math.Abs(k) + Math.Abs(m) + Math.Abs(n) + Math.Abs(p);
				 if (preSum  > end) continue;
			for (int q = 0; q <= end; q = (q == 0) ? 1 : (q > 0 ? -q : -q + 1))
			for (int r = 0; r <= end; r = (r == 0) ? 1 : (r > 0 ? -r : -r + 1))
			for (int s = 0; s <= end; s = (s == 0) ? 1 : (s > 0 ? -s : -s + 1))
			for (int t = 0; t <= end; t = (t == 0) ? 1 : (t > 0 ? -t : -t + 1))
			for (int u = 1; u <= end; u = (u == 0) ? 1 : (u > 0 ? -u : -u + 1))
			for (int v = 0; v <= end; v = (v == 0) ? 1 : (v > 0 ? -v : -v + 1))
			for (int w = 0; w <= end; w = (w == 0) ? 1 : (w > 0 ? -w : -w + 1))
			for (int y = 0; y <= end; y = (y == 0) ? 1 : (y > 0 ? -y : -y + 1))
			{   /*int w = 1;*/ int changeSum = preSum + Math.Abs(q-1) + Math.Abs(r) + Math.Abs(s) + Math.Abs(t) + Math.Abs(u-1) + Math.Abs(v) + Math.Abs(w-1);
				if (Math.Abs(u) == 0 /*|| (Math.Abs(v) == 0) */ || changeSum > end)
					continue;
				BigInteger result2 = (result >> v) + w;
				BigInteger mask22 = (BigInteger.One << (desiredStartSize+i)) - 1;
				BigInteger xTimesY22 = (((x >> (xLen - doubleDesiredStartSize + j)) + r) * (result2 + k)) >> (desiredStartSize - 1 + m);
				prod2 = ((result2 + q) << (doubleDesiredStartSize + t)) - u * ((result2 + n) * (((xTimesY22 + s) & mask22) - p));

				// Check Result
				int bitsToHide = 0;
				int prod2Size = (int)prod2.GetBitLength();
				BigInteger checkResult2 = 0;
				if (checkResultSize > prod2Size)
				{
					checkResult2 = checkResult >> (checkResultSize + bitsToHide - prod2Size);
					prod2 >>= bitsToHide;
				}
				else
				{
					checkResult2 = checkResult >> bitsToHide;
					prod2 >>= (prod2Size + bitsToHide - checkResultSize);
				}

				//prod1b |= mask2;
				//prod2  |= mask2;
				//Console.WriteLine($"Mask:{ToBinaryString(mask2)}");

				if (checkResult2 >> 5 == prod2 >> 5)// || (prod1>>1) == prod2 || prod1 == (prod2>>1) || (prod1 >> 1) == (prod2 >> 1) || (prod1 >> 2) == prod2 || prod1 == (prod2 >> 2) || (prod1 >> 2) == (prod2 >> 2))
				{
					//Console.WriteLine($"match: {fails} {ToBinaryString(prod1)}");
					if (firstDisplay == true)
						Console.WriteLine($"Sum	i	j	k	m	n	p	q	r	s	t	u	v	w");
					else
						Console.WriteLine($"{changeSum,2}	{i,2}	{j,2}	{k,2}	{m,2}	{n,2}	{p,2}	{q,2}	{r,2}	{s,2}	{t,2}	{u,2}	{v,2}	{w,2}");
					found++; firstDisplay = false;
					//Console.WriteLine($"prod1: {ToBinaryString(prod1b)}");
					//Console.WriteLine($"prod2: {ToBinaryString(prod2)}");
					//goto doneWithScan;
					//if (found > 4)
					//{ goto skippp; }
				}
				else
				{
					////Console.WriteLine($"{ToBinaryString(result)}|{ToBinaryString((BigInteger.One << doubleDesiredStartSize) - ((result + adj) * ((xTimesY & mask) - 0)))}");
					//if (fails == 0)
					//{
					//    Console.WriteLine($"prod1: {ToBinaryString(prod1b)}");
					//    Console.WriteLine($"prod2: {ToBinaryString(prod2)}");
					//    //Console.WriteLine($"{x}");
					//    //Console.WriteLine($"{ToBinaryString(x)}");
					//                                                //Console.WriteLine($"{ToBinaryString(prod1b-prod2)}");
					//                                            }
					//fails++;
				}
			}}
			//if (found <4)
			//{ }

			skippp:
			if (numOfNewtonSteps == 0)
				return prod2 >> (doubleDesiredStartSize - precisionBits);
			//Console.WriteLine($"{(found? "match" : "miss")}: [{fails}]"); //{ToBinaryString(prod1)} {prod1}
		}

		// back off until we see both a zero and one??

		result >>=  precisionBits - doubleDesiredStartSize;
		result >>= EXTRA_BITS_TO_REMOVE;


		int reduceBy = 0;
		if (result.IsEven)
			reduceBy = (int)BigInteger.TrailingZeroCount(result) + 1;
		else
			reduceBy = (int)BigInteger.TrailingZeroCount(~result) + 1;  //todo: need to check more then just 64 bits! (also, a loop might be faster going bit by bit)

		Console.WriteLine($"Ans_Bits:{ToBinaryShades((checkResult >> ((int)checkResult.GetBitLength() - (int)result.GetBitLength())) & 0xFFF),14}");
		Console.WriteLine($"LastBits:{ToBinaryShades(result & 0xFFF, 14)} >> {reduceBy}");
		//Console.WriteLine($"LastBits:{ToBinaryShades(~result & 0xFFF, 14)}");
		 
		if (desiredStartSize > 600)
		{ }
		 
		if (desiredStartSize > xLen)
		{
			result >>= (desiredStartSize - xLen);
			if (checkResult == result >> (desiredStartSize - xLen))
			{
				Console.WriteLine($"match and {desiredStartSize} > {xLen} "); //{ToBinaryString(prod1)} {prod1}
				if (numOfNewtonSteps == 0)
					return result;
			}
			else
			{
				if (result.GetBitLength() != xLen)
					Console.WriteLine($"incorrect Length:prod2[{result.GetBitLength()}] of xLen:{xLen}  (miss by {result.GetBitLength() - xLen})"); //{ToBinaryString(prod1)} {prod1}
				else
					Console.WriteLine($"fail {xLen}");
			}
		}
		else
		{
			result >>= reduceBy;
			desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;
		}
	}
}

public static BigInteger InverseBigInteger5(BigInteger x, int precisionBits)
{

	int xLen = (int)x.GetBitLength();
	if (precisionBits > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}


	//if (x.IsZero) // not needed since code below throws error
	//    throw new DivideByZeroException("Cannot compute the inverse of zero.");

	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	//if (x.GetBitLength() != precisionBits)
	//    throw new DivideByZeroException("TEST ERROR");

	//if (precisionBits < 53)
	//    return (BigInteger)(((double)(UInt128.One << (2 * precisionBits - 1))) / (double)x);

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - precisionBits;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - precisionBits + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + precisionBits - 1)) / x;
		//if ((int)BigInteger.Log2(res) + 1 != precisionBits)
		//{
		//    Console.WriteLine("XXXXXX");
		//}
		//res >>= ((int)BigInteger.Log2(res) + 1 - precisionBits);
		return res;
	}


	//if (xLen < 128)
	//{
	//    int desiredStartSize2 = precisionBits + 10;
	//    while (desiredStartSize2 > 64)
	//        desiredStartSize2 = ((desiredStartSize2) >> 1) + 1;

	//    UInt128 res = (UInt128.One << 127) / (ulong)(x >> (xLen - 64 + 1));
	//    BigInteger result2 = res >> ((int)UInt128.Log2(res) - desiredStartSize2 + 1); //we know UInt128.Log2(res) is 64?

	//    //BigInteger scaledOne3 = BigInteger.One << ((desiredStartSize2 << 1) + 0);
	//    //BigInteger result2 = (scaledOne3 / (x >> (xLen - desiredStartSize2 - 0 - 1)));

	//    //if (result2 != result3)
	//    //{ }
	//    //else
	//    //{ } 

	//    BigInteger scalingFactor = BigInteger.One << ((desiredStartSize2 << 1) + 1);
	//    BigInteger xTimesY = ((x >> (xLen - (desiredStartSize2 << 1))) * result2) >> (desiredStartSize2 - 1);
	//    BigInteger twoMinusXy = scalingFactor - xTimesY;
	//    result2 = (result2 * twoMinusXy) >> desiredStartSize2;
	//    desiredStartSize2 <<= 1;

	//    //if ((int)result.GetBitLength() != doubleDesiredStartSize)  { }
	//    result2 >>= ((desiredStartSize2) - precisionBits);

	//    return (isPos) ? result2 : -result2;
	//}

	//int bytes = x.GetByteCount();


	//if (x.IsPowerOfTwo)
	//    return x.Sign * BigInteger.One << (precisionBits - 1);


	//const int ExtraPrecision = 4;
	//if (precisionBits <= UseSimpleForSizesUnder)
	//{
	//    // Lets pre-scale x and just do simple BigInteger integer division
	//    BigInteger scaledOne = BigInteger.One << ((precisionBits << 1) + ExtraPrecision);
	//    return scaledOne / (x >> (xLen - precisionBits - ExtraPrecision - 1));
	//}

	////////  Get Starting Size  ////////
	//int numOfNewtonSteps = BitOperations.Log2((uint)(wantedPrecision / size)) + 2;
	//int wantedSize = (wantedPrecision >> numOfNewtonSteps) + 2;

	int desiredStartSize = precisionBits + 16;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 325)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}


	//int desiredStartSize2 = precisionBits + 16;
	//int numOfNewtonSteps = BitOperations.Log2((uint)((desiredStartSize2) / 325)) + 1;
	//int desiredStartSize = (desiredStartSize2 >> numOfNewtonSteps) + 2;

	BigInteger scaledOne2 = BigInteger.One << (desiredStartSize << 1);
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1));




	while (true)
	{
		numOfNewtonSteps--;
		int doubleDesiredStartSize = (desiredStartSize << 1);
		BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
		//BigInteger x2 = (x >> (xLen - doubleDesiredStartSize)) & mask; //~((x >> (xLen - doubleDesiredStartSize)) & mask) & mask;
		BigInteger xTimesY = (x >> (xLen - doubleDesiredStartSize)) * result >> (desiredStartSize - 1);
		//BigInteger xTimesY2 = (x >> (xLen - doubleDesiredStartSize)) & mask * result; // >> (desiredStartSize - 1-18);
		BigInteger twoMinusXy = scalingFactor - xTimesY;

		//BigInteger twoMinusXy1 =  ~(xTimesY & mask) & mask; 


		//Console.WriteLine($"{ToBinaryString(xTimesY1)}");
		////Console.WriteLine($"{ToBinaryString(xTimesY2)}");

		BigInteger mask = (BigInteger.One << desiredStartSize) - 1;
		Console.WriteLine($"{ToBinaryString(twoMinusXy)}");
		Console.WriteLine($"{ToBinaryString(twoMinusXy & mask)}");

		Console.WriteLine($"{ToBinaryString(result)}");

		BigInteger prod1 = result * twoMinusXy;
		BigInteger prod2 = (BigInteger.One << doubleDesiredStartSize) - (result * (xTimesY & mask));
		Console.WriteLine($"{ToBinaryString(prod1)}");
		Console.WriteLine($"{ToBinaryString(prod2)}");

		if (numOfNewtonSteps > 0)
			result = prod1 >> desiredStartSize;
		else
			return prod1 >> (desiredStartSize + doubleDesiredStartSize - precisionBits);

		desiredStartSize = doubleDesiredStartSize;
	}
}


//tuning stuff
//int A = 0; int B = 0; int C = 0; int D = 0;
//BigInteger scalingFactor = BigInteger.One >> (-2 * desiredStartSize - 1 + B + D);
//BigInteger xTimesY = ((x >> (xLen - 2 * desiredStartSize + A + D)) * result) >> (desiredStartSize - 1 + B - A);
//BigInteger twoMinusXy = (scalingFactor - xTimesY) >> (-B + C + D);
//result = (result* twoMinusXy) >> (desiredStartSize - C + 0);
//if (ToBinaryString(result4).Zip(ToBinaryString(result2), (c1, c2) => c1 == c2).TakeWhile(b => b).Count() >= 1293 && (int)result4.GetBitLength() == 1296)
//   Console.WriteLine($" Correct: {ToBinaryString(result).Zip(ToBinaryString(result2), (c1, c2) => c1 == c2).TakeWhile(b => b).Count()} of {result.GetBitLength()}");


// ChatGPT 10/8/2024 - o1 preview  
public static BigInteger InverseBigInteger4(BigInteger x, int precisionBits)
{
	if (x.IsZero)
		throw new DivideByZeroException("Cannot compute the inverse of zero.");

	bool isNegative = x.Sign < 0;
	if (isNegative)
		x = BigInteger.Abs(x);

	// Scaling factor: 2^(2 * precisionBits)
	BigInteger scalingFactor = BigInteger.One << (2 * precisionBits);

	BigInteger result;

	// Try using ulong for the initial division if possible
	if (x <= uint.MaxValue && (2 * precisionBits) <= 63)
	{
		// Use uint for x and scaling factor to prevent overflow
		uint xULong = (uint)x;
		ulong scalingULong = 1UL << (2 * precisionBits);

		// Perform division using ulong
		ulong initialInverse = scalingULong / xULong;
		result = new BigInteger(initialInverse);
	}
	else if (x <= ulong.MaxValue && (2 * precisionBits) <= 63)
	{
		// Use BigInteger for scaling factor to prevent overflow
		BigInteger scalingULong = BigInteger.One << (8 * precisionBits);

		// Perform division using BigInteger (since scaling factor might be large)
		result = scalingULong / x;
	}
	else
	{
		// Fall-back to using double for initial approximation
		double xDouble = (double)x;
		double scalingDouble = Math.Pow(2, 2 * precisionBits);

		// Perform division using double
		double initialInverseDouble = scalingDouble / xDouble;
		result = new BigInteger(initialInverseDouble);
	}

	// If high precision is required, refine the result using Newton-Raphson method
	if (precisionBits > 64)
	{
		result = InverseUsingNewtonRaphson(x, precisionBits, result);
	}

	if (isNegative)
		result = -result;

	return result;

	static BigInteger InverseUsingNewtonRaphson(BigInteger x, int precisionBits, BigInteger initialApproximation)
	{
		// Scaling factor: 2^(precisionBits)
		BigInteger scalingFactor = BigInteger.One << precisionBits;

		BigInteger y = initialApproximation;

		// Number of iterations for convergence
		int iterations = (int)Math.Ceiling(Math.Log2(precisionBits)) + 1;

		for (int i = 0; i < iterations; i++)
		{
			// y = y * (2 * scalingFactor - x * y) / scalingFactor
			BigInteger xTimesY = (x * y) >> precisionBits;
			BigInteger twoMinusXy = (scalingFactor << 1) - xTimesY;
			y = (y * twoMinusXy) >> precisionBits;
		}

		return y;
	}
}



// ChatGPT 10/8/2024 - o1 preview
public static BigInteger InverseBigInteger3(BigInteger x, int precisionBits)
{
	if (x.IsZero)
		throw new DivideByZeroException("Cannot compute the inverse of zero.");

	bool isNegative = x.Sign < 0;
	if (isNegative)
		x = BigInteger.Abs(x);

	// Scaling factor: 2^(precisionBits)
	BigInteger scalingFactor = BigInteger.One << precisionBits;

	// Use higher scaling factor for initial approximation
	BigInteger initialScalingFactor = BigInteger.One << (precisionBits * 2);

	// Initial approximation
	
	BigInteger y = (initialScalingFactor>>8) / (x>>8);

	// Number of iterations
	int iterations = (int)Math.Ceiling(Math.Log(precisionBits) / Math.Log(2)) + 1;

	//int iterations2 = BitOperations.Log2((uint)(x.GetBitLength()/ precisionBits)) + 2;

	for (int i = 0; i < iterations; i++)
	{
		// y = y * (2 * scalingFactor - x * y) / scalingFactor
		BigInteger xTimesY = (x * y) >> precisionBits;
		BigInteger twoMinusXy = (scalingFactor << 1) - xTimesY;
		y = (y * twoMinusXy) >> precisionBits;
	}

	if (isNegative)
		y = -y;

	return y;
}

// ChatGPT 10/8/2024 - o1 preview  (version 2 by ChatGPT after feedback)

//public static BigInteger InverseBigInteger2(BigInteger x, int precisionBits)
//{
//    if (x.IsZero)
//        throw new DivideByZeroException("Cannot compute the inverse of zero.");

//    bool isNegative = x.Sign < 0;
//    if (isNegative)
//        x = BigInteger.Abs(x);

//    // Scaling factor: 2^(precisionBits)
//    BigInteger scalingFactor = BigInteger.One << precisionBits;

//    // Use higher scaling factor for initial approximation
//    BigInteger initialScalingFactor = BigInteger.One << (precisionBits * 2);

//    // Initial approximation
//    BigInteger y = initialScalingFactor / x;

//    // Number of iterations
//    int iterations = (int)Math.Ceiling(Math.Log(precisionBits) / Math.Log(2)) + 1;

//    for (int i = 0; i < iterations; i++)
//    {
//        // y = y * (2 * scalingFactor - x * y) / scalingFactor
//        BigInteger xTimesY = (x * y) >> precisionBits;
//        BigInteger twoMinusXy = (scalingFactor << 1) - xTimesY;
//        y = (y * twoMinusXy) >> precisionBits;
//    }

//    if (isNegative)
//        y = -y;

//    return y;
//}

// ChatGPT 10/7/2024 - o1 preview  (version 1)
public static BigInteger InverseBigInteger1(BigInteger x, int precisionBits)
{
	if (x.IsZero)
		throw new DivideByZeroException("Cannot compute the inverse of zero.");

	bool isNegative = x.Sign < 0;
	if (isNegative)
		x = BigInteger.Abs(x);

	// Scaling factor: 2^precisionBits
	BigInteger scalingFactor = BigInteger.One << precisionBits;

	// Initial approximation (can be improved)
	BigInteger y = scalingFactor / x;

	// Number of iterations (log2(precisionBits)) for convergence
	int iterations = (int)Math.Ceiling(Math.Log(precisionBits) / Math.Log(2)) + 1;

	for (int i = 0; i < iterations; i++)
	{
		// y = y * (2 * scalingFactor - x * y) / scalingFactor
		BigInteger xTimesY = (x * y) >> precisionBits;
		BigInteger twoMinusXy = (BigInteger.One << 1) * scalingFactor - xTimesY;
		y = (y * twoMinusXy) >> precisionBits;
	}

	if (isNegative)
		y = -y;

	return y;
}