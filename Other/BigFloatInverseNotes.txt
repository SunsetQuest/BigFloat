// below is as of 12/10/2024.  There are several different versions.  

public static BigInteger InverseBigIntegerClassicNewton(BigInteger x, int requestedPrecision)
{
	int xLen = (int)x.GetBitLength();
	if (requestedPrecision > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}

	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - requestedPrecision;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - requestedPrecision + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
		return res;
	}

	////////  Get Starting Size  ////////
	const int EXTRA = 8;
	int desiredStartSize = requestedPrecision + EXTRA * 2;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 330)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}

	BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + EXTRA * 2));
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - EXTRA));

	int reduceBy2 = (int)BigInteger.TrailingZeroCount((result.IsEven) ? result : (~result)) + 1; // need one for things like ..100000
	result >>= reduceBy2;

	desiredStartSize = desiredStartSize - reduceBy2 + EXTRA; 


	int EXTRA_BITS_TO_REMOVE = 1;// 3;
	while (desiredStartSize <= requestedPrecision)
	{
		numOfNewtonSteps--;
		int doubleDesiredStartSize = (desiredStartSize << 1);

		// Newton version
		BigInteger xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1);
		BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
		BigInteger twoMinusXy = scalingFactor - xTimesY;
		result = (result * twoMinusXy) >> (desiredStartSize + EXTRA_BITS_TO_REMOVE);

		//// back off until we see both a zero and one??
		int reduceBy = (int)BigInteger.TrailingZeroCount((result.IsEven) ? result : (~result)) + 1; // need one for things like ..100000
		result >>= reduceBy;

		desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;
	}


	BigInteger tempResult = result >> desiredStartSize - requestedPrecision;

	return tempResult;

}

public static BigInteger InverseBigInteger(BigInteger x, int requestedPrecision)
{
	int xLen = (int)x.GetBitLength();
	if (requestedPrecision > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}

	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - requestedPrecision;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - requestedPrecision + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
		return res;
	}

	////////  Get Starting Size  ////////
	const int EXTRA = 8;
	int desiredStartSize = requestedPrecision + EXTRA*2;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 330)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}

	BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + EXTRA*2));
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - EXTRA));

	//result >>= 2;

	int reduceBy2 = (int)BigInteger.TrailingZeroCount((result.IsEven) ? result : (~result)) + 1; // need one for things like ..100000
	result >>= reduceBy2;

	//int lastBits = (byte)(result & 0xFF);
	//if (lastBits == 0)
	//{
	//    // possible to high
	//    scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + EXTRA * 4));
	//    result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - EXTRA * 2));
	//    lastBits = (ushort)(result & 0xFFFF);
	//    if (lastBits == 0)
	//    {
	//        // more checking here
	//    }
	//    result >>= EXTRA * 2;
	//}
	//else
	//{
	//    result >>= EXTRA;
	//}

	// desiredStartSize = (int)result.GetBitLength();

	// Benchmarks and timings
	// Bits: 1202 -> 1.46/48/46    51/51/52   
	// Extra Size to 7  ->  1.51/46/52/46  (put back)
	// 325 -> 350           1.50,51,51
	// 325 -> 300           1.50,47,45
	// 325 -> 330           1.50,52,50     (keep)
	// .net 9               1.32,38,39     (keep - since we need to anyway)
	//                      1.36,42,40,43,35,38,31
	// 39 34 32 36  34 36 30
	desiredStartSize = desiredStartSize - reduceBy2 + EXTRA; //(int)result.GetBitLength();
	//desiredStartSize = (int)result.GetBitLength();
	//BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
	//int orgCorrectBits = ToBinaryString(result).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	////int cResLen = (int)checkResult.GetBitLength();
	////int correctBits = ToolsForOther.ToBinaryString(checkResult).Zip(ToolsForOther.ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	////Console.WriteLine($"Ans:   {ToBinaryShades(checkResult)} [{checkResult.GetBitLength()}]");
	////Console.WriteLine($"result:{ToBinaryShades(result)} [{resLen}] (correct:{orgCorrectBits} of {resLen}) LastBits:{Convert.ToString(lastBits, 2)}");
	//if (orgCorrectBits != resLen)
	//    Console.WriteLine($"result:{ToBinaryShades(result)} [{resLen}] FAIL!!!!!!!!! (correct:{orgCorrectBits} of {resLen})");


	int EXTRA_BITS_TO_REMOVE = 1;// 3;
	while (desiredStartSize <= requestedPrecision)
	{
		numOfNewtonSteps--;
		int doubleDesiredStartSize = (desiredStartSize << 1);


		if (desiredStartSize > 1000)
		{
			////////////////////// Newton version  //////////////////////
			BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
			BigInteger twoMinusXy = scalingFactor - xTimesY;
			result = (result * twoMinusXy) >> (desiredStartSize + EXTRA_BITS_TO_REMOVE);
		}
		else
		{
			////////////////////// NewtonPlus version  //////////////////////
			result++;
			BigInteger mask22 = (BigInteger.One << (desiredStartSize + 1)) - 1;
			BigInteger xTimesY22 = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1); // future: we only need the bottom half of this.
			result = ((result << (doubleDesiredStartSize)) - (result * (xTimesY22 & mask22))) >> (desiredStartSize + EXTRA_BITS_TO_REMOVE);
		}

		//result >>= EXTRA_BITS_TO_REMOVE;


		//// Check if correct so far and output info if not
		//int correctBits2 = ToBinaryString(result).Zip(ToBinaryString(checkResult), static (c1, c2) => c1 == c2).TakeWhile(static b => b).Count();
		//if (correctBits2 < Math.Min(requestedPrecision, doubleDesiredStartSize /*- reduceBy*/ - EXTRA_BITS_TO_REMOVE))
		//{
		//    //Console.WriteLine($"not 100% !!\r\nAns: {ToBinaryString(checkResult)}[{checkResult.GetBitLength()}]\r\nRes: {ToBinaryString(result)}[{result.GetBitLength()}]");
		//}


		// Benchmarks 32 30 45 41 39
		//// back off until we see both a zero and one??
		int reduceBy = (int)BigInteger.TrailingZeroCount((result.IsEven) ? result : (~result)) + 1; // need one for things like ..100000
		result >>= reduceBy;

		// Benchmarks 29 27 35 33
		// Fast but might have issue with lots of zeros
		//UInt64 tempVal = (UInt64)(0xFFFFFFFF & result);
		//int reduceBy = (int)UInt64.TrailingZeroCount(((tempVal & 0x1) == 0) ? tempVal : (~tempVal)) + 1; // need one for things like ..100000
		//// if (reduceBy > 62) do full
		//result >>= reduceBy;

		// Benchmarks 30 36 30
		//int reduceBy = 1;
		//if (result.IsEven)
		//{
		//    while ((result >> reduceBy).IsEven) reduceBy++;
		//}
		//else
		//{
		//    while (!(result >> reduceBy).IsEven) reduceBy++;
		//}
		//reduceBy++;
		//result >>= reduceBy;


		//int reduceBy;
		//int tempVal = (int)(0xF & result);
		//if (tempVal != 0 || tempVal != 0xF)
		//{
		//    result >>= 4;
		//    reduceBy = 4;
		//}
		//else
		//{
		//    tempVal = (int)(0xFF & result);
		//    if (tempVal != 0 || tempVal != 0xF)
		//        result >>= 8;
		//    reduceBy = 8;
		//}

		desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;

		//if (desiredStartSize != result.GetBitLength()) Console.WriteLine($"SIZE FAIL: {desiredStartSize} != {result.GetBitLength()}");
	}


	BigInteger tempResult = result >> desiredStartSize - requestedPrecision;
	//int correctBits = ToBinaryString(tempResult).Zip(ToBinaryString(checkResult), static (c1, c2) => c1 == c2).TakeWhile(static b => b).Count();
	////BigInteger resultT = prod2 >> (requestedPrecision - doubleDesiredStartSize + EXTRA_BITS_TO_REMOVE);
	////Console.WriteLine($"Result:{ToBinaryShades(resultT)} [{resultT.GetBitLength()}]");
	////Console.WriteLine($"xTimesY22:{(xTimesY22 >> (desiredStartSize - 8)).GetBitLength()}[{xTimesY22.GetBitLength()}] desiredStartSize:{desiredStartSize} xTimesY22:{ToBinaryString(/*0x3FF &*/ (xTimesY22 >> (desiredStartSize - 0)), 1)} {ToBinaryString(0xFFFF & (xTimesY22 >> (desiredStartSize)), 1)} botOfRes:{ToBinaryString(result2>>((int)result2.GetBitLength()-8), 8)}...{ToBinaryString(0xFF & result2, 8)}"); //{ToBinaryString(prod1)} {prod1}

	//if (checkResult != tempResult)
	//{
	//    Console.WriteLine($"FAIL!!!! correctBits:{correctBits} of {desiredStartSize}");
	//    Console.WriteLine($"Ans: {ToBinaryString(checkResult)}\r\nRes: {ToBinaryString(result)}");
	//    if (tempResult.GetBitLength() != requestedPrecision)
	//    {
	//        Console.WriteLine($"!!!! incorrect length resultLen:{tempResult.GetBitLength()} xLen:{xLen}  (miss by {tempResult.GetBitLength() - xLen})"); //{ToBinaryString(prod1)} {prod1}
	//    }
	//    else
	//    {
	//        Console.WriteLine($"fail\r\nAns: {ToBinaryString(checkResult)}\r\nRes: {ToBinaryString(tempResult)}");
	//    }
	//}
	return tempResult;
	
}

public static BigInteger InverseBigInteger7(BigInteger x, int requestedPrecision)
{

	int xLen = (int)x.GetBitLength();
	if (requestedPrecision > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}

	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - requestedPrecision;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - requestedPrecision + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + requestedPrecision - 1)) / x;
		return res;
	}


	////////  Get Starting Size  ////////
	//int numOfNewtonSteps = BitOperations.Log2((uint)(wantedPrecision / size)) + 2;
	//int wantedSize = (wantedPrecision >> numOfNewtonSteps) + 2;

	int desiredStartSize = requestedPrecision + 16;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 325)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}
	int startedSteps = numOfNewtonSteps;

	BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + 16));
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - 8));

	int lastBits = (byte)(result & 0xFF);
	if (lastBits == 0)
	{
		// possible to high
		scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + 32));
		result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - 16));
		lastBits = (ushort)(result & 0xFFFF);
		if (lastBits == 0)
		{
			// more checking here
		}
		result >>= 16;
	}
	else
	{
		result >>= 8;
	}

	// desiredStartSize = (int)result.GetBitLength();



	int resLen = (int)result.GetBitLength();
	BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
	int orgCorrectBits = ToBinaryString(result).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	//int cResLen = (int)checkResult.GetBitLength();
	//int correctBits = ToolsForOther.ToBinaryString(checkResult).Zip(ToolsForOther.ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	//Console.WriteLine($"Ans:   {ToBinaryShades(checkResult)} [{checkResult.GetBitLength()}]");
	//Console.WriteLine($"result:{ToBinaryShades(result)} [{resLen}] (correct:{orgCorrectBits} of {resLen}) LastBits:{Convert.ToString(lastBits, 2)}");
	if (orgCorrectBits != resLen)
		Console.WriteLine($"result:{ToBinaryShades(result)} [{resLen}] FAIL!!!!!!!!! (correct:{orgCorrectBits} of {resLen})");


	int EXTRA_BITS_TO_REMOVE = 1;// 3;
	while (true)
	{
		numOfNewtonSteps--;
		int doubleDesiredStartSize = (desiredStartSize << 1);
		BigInteger xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1);

		{ // NewtonPlus version
			BigInteger result2 = result + 1;
			BigInteger mask22 = (BigInteger.One << (desiredStartSize + 1)) - 1;
			BigInteger xTimesY22 = ((x >> (xLen - doubleDesiredStartSize)) * result2) >> (desiredStartSize - 1); // future: we only need the bottom half of this.
			result = ((result2 << (doubleDesiredStartSize)) - (result2 * (xTimesY22 & mask22))) >> desiredStartSize;
		}


		if (false)
		{
			bool firstDisplay = true;
			int checkResultSize = (int)checkResult.GetBitLength();
			int end = 4; int fails = 0; int found = 0;
			BigInteger prod2 = 0;
			for (int i = 0; i <= end; i = (i == 0) ? 1 : (i > 0 ? -i : -i + 1))
				for (int j = 0; j <= end; j = (j == 0) ? 1 : (j > 0 ? -j : -j + 1))
					for (int k = 0; k <= end; k = (k == 0) ? 1 : (k > 0 ? -k : -k + 1))
						for (int m = 0; m <= end; m = (m == 0) ? 1 : (m > 0 ? -m : -m + 1))
							for (int n = 0; n <= end; n = (n == 0) ? 1 : (n > 0 ? -n : -n + 1))
								for (int p = 0; p <= end; p = (p == 0) ? 1 : (p > 0 ? -p : -p + 1))
								{
									int preSum = Math.Abs(i) + Math.Abs(j) + Math.Abs(k) + Math.Abs(m) + Math.Abs(n) + Math.Abs(p);
									if (preSum > end) continue;
									for (int q = 0; q <= end; q = (q == 0) ? 1 : (q > 0 ? -q : -q + 1))
										for (int r = 0; r <= end; r = (r == 0) ? 1 : (r > 0 ? -r : -r + 1))
											for (int s = 0; s <= end; s = (s == 0) ? 1 : (s > 0 ? -s : -s + 1))
												for (int t = 0; t <= end; t = (t == 0) ? 1 : (t > 0 ? -t : -t + 1))
													for (int u = 1; u <= end; u = (u == 0) ? 1 : (u > 0 ? -u : -u + 1))
														for (int v = 0; v <= end; v = (v == 0) ? 1 : (v > 0 ? -v : -v + 1))
															for (int w = 0; w <= end; w = (w == 0) ? 1 : (w > 0 ? -w : -w + 1))
																for (int y = 0; y <= end; y = (y == 0) ? 1 : (y > 0 ? -y : -y + 1))
																{   /*int w = 1;*/
																	int changeSum = preSum + Math.Abs(q - 1) + Math.Abs(r) + Math.Abs(s) + Math.Abs(t) + Math.Abs(u - 1) + Math.Abs(v) + Math.Abs(w - 1);
																	if (Math.Abs(u) == 0 /*|| (Math.Abs(v) == 0) */ || changeSum > end)
																		continue;
																	BigInteger result2 = (result >> v) + w;
																	BigInteger mask22 = (BigInteger.One << (desiredStartSize + i)) - 1;
																	BigInteger xTimesY22 = (((x >> (xLen - doubleDesiredStartSize + j)) + r) * (result2 + k)) >> (desiredStartSize - 1 + m);
																	prod2 = ((result2 + q) << (doubleDesiredStartSize + t)) - u * ((result2 + n) * (((xTimesY22 + s) & mask22) - p));

																	// Check Result
																	int bitsToHide = 0;
																	int prod2Size = (int)prod2.GetBitLength();
																	BigInteger checkResult2 = 0;
																	if (checkResultSize > prod2Size)
																	{
																		checkResult2 = checkResult >> (checkResultSize + bitsToHide - prod2Size);
																		prod2 >>= bitsToHide;
																	}
																	else
																	{
																		checkResult2 = checkResult >> bitsToHide;
																		prod2 >>= (prod2Size + bitsToHide - checkResultSize);
																	}

																	//prod1b |= mask2;
																	//prod2  |= mask2;
																	//Console.WriteLine($"Mask:{ToBinaryString(mask2)}");

																	if (checkResult2 >> 5 == prod2 >> 5)// || (prod1>>1) == prod2 || prod1 == (prod2>>1) || (prod1 >> 1) == (prod2 >> 1) || (prod1 >> 2) == prod2 || prod1 == (prod2 >> 2) || (prod1 >> 2) == (prod2 >> 2))
																	{
																		//Console.WriteLine($"match: {fails} {ToBinaryString(prod1)}");
																		if (firstDisplay == true)
																			Console.WriteLine($"Sum	i	j	k	m	n	p	q	r	s	t	u	v	w");
																		else
																			Console.WriteLine($"{changeSum,2}	{i,2}	{j,2}	{k,2}	{m,2}	{n,2}	{p,2}	{q,2}	{r,2}	{s,2}	{t,2}	{u,2}	{v,2}	{w,2}");
																		found++; firstDisplay = false;
																		//Console.WriteLine($"prod1: {ToBinaryString(prod1b)}");
																		//Console.WriteLine($"prod2: {ToBinaryString(prod2)}");
																		//goto doneWithScan;
																		//if (found > 4)
																		//{ goto skippp; }
																	}
																	else
																	{
																		////Console.WriteLine($"{ToBinaryString(result)}|{ToBinaryString((BigInteger.One << doubleDesiredStartSize) - ((result + adj) * ((xTimesY & mask) - 0)))}");
																		//if (fails == 0)
																		//{
																		//    Console.WriteLine($"prod1: {ToBinaryString(prod1b)}");
																		//    Console.WriteLine($"prod2: {ToBinaryString(prod2)}");
																		//    //Console.WriteLine($"{x}");
																		//    //Console.WriteLine($"{ToBinaryString(x)}");
																		//                                                //Console.WriteLine($"{ToBinaryString(prod1b-prod2)}");
																		//                                            }
																		//fails++;
																	}
																}
								}
							//if (found <4)
							//{ }

							skippp:
			if (numOfNewtonSteps == 0)
				return prod2 >> (doubleDesiredStartSize - requestedPrecision);
			//Console.WriteLine($"{(found? "match" : "miss")}: [{fails}]"); //{ToBinaryString(prod1)} {prod1}
		}


		// Are we done? 
		//   If yes, Check if correct?

		//   If no, Check if first n bits are correct.


		//Console.WriteLine($"Ans: {ToBinaryString(checkResult)}\r\nRes: {ToBinaryString(result)}");

		BigInteger tempResult = result >> doubleDesiredStartSize - requestedPrecision;
		int score = ToBinaryString(tempResult).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
		//BigInteger resultT = prod2 >> (requestedPrecision - doubleDesiredStartSize + EXTRA_BITS_TO_REMOVE);
		//Console.WriteLine($"Result:{ToBinaryShades(resultT)} [{resultT.GetBitLength()}]");
		//Console.WriteLine($"xTimesY22:{(xTimesY22 >> (desiredStartSize - 8)).GetBitLength()}[{xTimesY22.GetBitLength()}] desiredStartSize:{desiredStartSize} xTimesY22:{ToBinaryString(/*0x3FF &*/ (xTimesY22 >> (desiredStartSize - 0)), 1)} {ToBinaryString(0xFFFF & (xTimesY22 >> (desiredStartSize)), 1)} botOfRes:{ToBinaryString(result2>>((int)result2.GetBitLength()-8), 8)}...{ToBinaryString(0xFF & result2, 8)}"); //{ToBinaryString(prod1)} {prod1}

		if (numOfNewtonSteps == 0)
		{
			if (checkResult == tempResult)
			{
				//Console.WriteLine($"match correctBits:{score} of {xLen}"); //{ToBinaryString(prod1)} {prod1}
			}
			else
			{
				if (tempResult.GetBitLength() != requestedPrecision)
					Console.WriteLine($"incorrect Length:result[{tempResult.GetBitLength()}] of xLen:{xLen}  (miss by {tempResult.GetBitLength() - xLen}) correctBits:{score}"); //{ToBinaryString(prod1)} {prod1}
				else
				{
					Console.WriteLine($"fail\r\nAns: {ToBinaryString(checkResult)}\r\nRes: {ToBinaryString(tempResult)}");
				}
			}
			return tempResult;
		}

		result >>= EXTRA_BITS_TO_REMOVE;


		// back off until we see both a zero and one??
		int reduceBy = 0;
		if (result.IsEven)
			reduceBy = (int)BigInteger.TrailingZeroCount(result) + 1;
		else
			reduceBy = (int)BigInteger.TrailingZeroCount(~result) + 1;  //todo: need to check more then just 64 bits! (also, a loop might be faster going bit by bit)

		//Console.WriteLine($"Ans_Bits:{ToBinaryShades((checkResult >> ((int)checkResult.GetBitLength() - (int)result.GetBitLength())) & 0xFFF),14}");
		//Console.WriteLine($"LastBits:{ToBinaryShades(result & 0xFFF, 14)} >> {reduceBy}");
		//Console.WriteLine($"LastBits:{ToBinaryShades(~result & 0xFFF, 14)}");

		if (desiredStartSize > 600)
		{ }

		if (desiredStartSize > xLen)
		{
			result >>= (desiredStartSize - xLen);
			if (checkResult == result >> (desiredStartSize - xLen))
			{
				Console.WriteLine($"match and {desiredStartSize} > {xLen} "); //{ToBinaryString(prod1)} {prod1}
				if (numOfNewtonSteps == 0)
					return result;
			}
			else
			{
				if (result.GetBitLength() != xLen)
					Console.WriteLine($"incorrect Length:prod2[{result.GetBitLength()}] of xLen:{xLen}  (miss by {result.GetBitLength() - xLen})"); //{ToBinaryString(prod1)} {prod1}
				else
					Console.WriteLine($"fail {xLen}");
			}
		}
		else
		{
			result >>= reduceBy;
			desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;
		}
	}
}

public static BigInteger InverseBigInteger6(BigInteger x, int precisionBits)
{

	int xLen = (int)x.GetBitLength();
	if (precisionBits > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}


	//if (x.IsZero) // not needed since code below throws error
	//    throw new DivideByZeroException("Cannot compute the inverse of zero.");
	 
	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	//if (x.GetBitLength() != precisionBits)
	//    throw new DivideByZeroException("TEST ERROR");

	//if (precisionBits < 53)
	//    return (BigInteger)(((double)(UInt128.One << (2 * precisionBits - 1))) / (double)x);

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - precisionBits;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - precisionBits + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + precisionBits - 1)) / x;
		//if ((int)BigInteger.Log2(res) + 1 != precisionBits)
		//{
		//    Console.WriteLine("XXXXXX");
		//}
		//res >>= ((int)BigInteger.Log2(res) + 1 - precisionBits);
		return res;
	}
	 

	//if (xLen < 128)
	//{
	//    int desiredStartSize2 = precisionBits + 10;
	//    while (desiredStartSize2 > 64)
	//        desiredStartSize2 = ((desiredStartSize2) >> 1) + 1;

	//    UInt128 res = (UInt128.One << 127) / (ulong)(x >> (xLen - 64 + 1));
	//    BigInteger result2 = res >> ((int)UInt128.Log2(res) - desiredStartSize2 + 1); //we know UInt128.Log2(res) is 64?

	//    //BigInteger scaledOne3 = BigInteger.One << ((desiredStartSize2 << 1) + 0);
	//    //BigInteger result2 = (scaledOne3 / (x >> (xLen - desiredStartSize2 - 0 - 1)));

	//    //if (result2 != result3)
	//    //{ }
	//    //else
	//    //{ } 

	//    BigInteger scalingFactor = BigInteger.One << ((desiredStartSize2 << 1) + 1);
	//    BigInteger xTimesY = ((x >> (xLen - (desiredStartSize2 << 1))) * result2) >> (desiredStartSize2 - 1);
	//    BigInteger twoMinusXy = scalingFactor - xTimesY;
	//    result2 = (result2 * twoMinusXy) >> desiredStartSize2;
	//    desiredStartSize2 <<= 1;

	//    //if ((int)result.GetBitLength() != doubleDesiredStartSize)  { }
	//    result2 >>= ((desiredStartSize2) - precisionBits);

	//    return (isPos) ? result2 : -result2;
	//}

	//int bytes = x.GetByteCount();


	//if (x.IsPowerOfTwo)
	//    return x.Sign * BigInteger.One << (precisionBits - 1);


	//const int ExtraPrecision = 4;
	//if (precisionBits <= UseSimpleForSizesUnder)
	//{
	//    // Lets pre-scale x and just do simple BigInteger integer division
	//    BigInteger scaledOne = BigInteger.One << ((precisionBits << 1) + ExtraPrecision);
	//    return scaledOne / (x >> (xLen - precisionBits - ExtraPrecision - 1));
	//}

	////////  Get Starting Size  ////////
	//int numOfNewtonSteps = BitOperations.Log2((uint)(wantedPrecision / size)) + 2;
	//int wantedSize = (wantedPrecision >> numOfNewtonSteps) + 2;

	int desiredStartSize = precisionBits + 16;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 325)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}
	int startedSteps = numOfNewtonSteps;

	//int desiredStartSize2 = precisionBits + 16;
	//int numOfNewtonSteps = BitOperations.Log2((uint)((desiredStartSize2)a / 325)) + 1;
	//int desiredStartSize = (desiredStartSize2 >> numOfNewtonSteps) + 2;


	//BigInteger scaledOne2 = (BigInteger.One << (desiredStartSize << 1));
	//BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1));
	BigInteger scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + 16));
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 -8));

	int lastBits = (byte)(result & 0xFF);
	if (lastBits == 0)
	{
		// possible to high
		scaledOne2 = (BigInteger.One << ((desiredStartSize << 1) + 32));
		result = scaledOne2 / (x >> (xLen - desiredStartSize - 1 - 16));
		lastBits = (UInt16)(result & 0xFFFF);
		if (lastBits == 0)
		{

		}
		// back off until we see both a zero and one??
		result >>= 16;

	}
	else if (lastBits == 255)
	{
		// possible to high
		result >>= 8;
	}
	else
	{
		result >>= 8;
	}

	//result >>= 30;

	//BigInteger test = x * result;
	//Console.WriteLine($"test:{ToBinaryString(test)} [{test.GetBitLength()}]");

	// check result - maybe an issue with starting "result" not being accurate?

	int resLen = (int)result.GetBitLength();
	BigInteger checkResult = (BigInteger.One << (xLen + xLen - 1)) / x;
	//int cResLen = (int)checkResult.GetBitLength();
	//int correctBits = ToolsForOther.ToBinaryString(checkResult).Zip(ToolsForOther.ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
	Console.WriteLine($"Ans:   {ToBinaryShades(checkResult)} [{checkResult.GetBitLength()}]");
	Console.WriteLine($"result:{ToBinaryShades(result)} [{result.GetBitLength()}]");

	int EXTRA_BITS_TO_REMOVE = 1;// 3;
	while (true)
	{
		numOfNewtonSteps--;
		//x = BigInteger.Parse("202093266059557925115266673399374673120617825428395545383299518550312490481423064232700602696581628212776090250332862778427463835814523593722050099003906655602355295662034260835350794263619979624501976232828646123677039779210979798544515");
		int doubleDesiredStartSize = (desiredStartSize << 1);
		BigInteger xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1);


		//// Newton version
		//{
		//    BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
		//    BigInteger twoMinusXy = scalingFactor - xTimesY;
		//    BigInteger prod1 = (result * twoMinusXy) >> desiredStartSize;
		//    Console.WriteLine($"prod1: {ToBinaryString(prod1)} [{prod1.GetBitLength()}]");
		//    if (numOfNewtonSteps == 0)
		//    {
		//        prod1 >>= (doubleDesiredStartSize - precisionBits);
		//        int correctBits = ToBinaryString(prod1).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();
		//        if (checkResult >> 5 == prod1 >> 5)
		//            Console.WriteLine($"match Correct:{correctBits}");
		//        else
		//            Console.WriteLine($"fail Correct:{correctBits}");

		//        return prod1;
		//    }
		//} 



		// NewtonPlus version
		{
			//if (doubleDesiredStartSize == xTimesY.GetBitLength())  // if 111111111111111111111111010100011... (should be 1000000000000000000010100011...)
			//    result >>= 1;
			
			//BigInteger mask = (BigInteger.One << desiredStartSize) - 1;
			//BigInteger prod2 = ((result << doubleDesiredStartSize) - (result * (xTimesY & mask))) >> desiredStartSize;
			//Console.WriteLine($"     : {ToBinaryString((result << doubleDesiredStartSize))}");
			//Console.WriteLine($"-    : {ToBinaryString((result * (xTimesY & mask)))}");
			//Console.WriteLine($"prod2: {ToBinaryString(prod2)} [{prod2.GetBitLength()}]");


			int[] ii = new int[4], tt = new int[4], vv = new int[4]; // u=1, q=1, w=1
			ii[0] = 1; tt[0] = 0; vv[0] = 0; //  E(option 1)
			ii[1] = 0; tt[1] =-1; vv[1] = 0; //  B
			ii[2] = 1; tt[2]= -1; vv[2] = 0; //  B1
			//ii[3] = 0; tt[3]=  0; vv[3] = -1; //  C  (not very common)
			ii[3] = 0; tt[3]=  0; vv[3] = 0; //  C  (not very common)
			BigInteger prod2 = 0;
			int bestScore = 0; int bestIndex = 0; BigInteger bestResult = 0;
			for (int i = 0; i < vv.Length; i++)
			{
				BigInteger result2 = (result >> vv[i]) + 1;
				BigInteger mask22 = (BigInteger.One << (desiredStartSize + ii[i])) - 1;
				BigInteger xTimesY22 = (((x >> (xLen - doubleDesiredStartSize))) * (result2)) >> (desiredStartSize - 1);
				prod2 = ((result2) << (doubleDesiredStartSize + tt[i])) - ((result2) * (((xTimesY22) & mask22)));

				prod2 >>= (doubleDesiredStartSize - precisionBits);
				prod2 >>= desiredStartSize + tt[i];
				int score = ToBinaryString(prod2).Zip(ToBinaryString(checkResult), (c1, c2) => c1 == c2).TakeWhile(b => b).Count();

				if (score > bestScore)
				{
					bestScore = score;
					bestResult = prod2;
					bestIndex = i;
				}

				BigInteger resultT = prod2 >> (precisionBits - doubleDesiredStartSize + EXTRA_BITS_TO_REMOVE);
				Console.WriteLine($"Result:{ToBinaryShades(resultT)} [{resultT.GetBitLength()}]");

				if (numOfNewtonSteps == 0)
					if (checkResult >> 5 == prod2 >> 5)
					{
						Console.WriteLine($"match correctBits:{score} of {xLen} using {i}"); //{ToBinaryString(prod1)} {prod1}
						if (numOfNewtonSteps == 0)
							return prod2;
					}
					else
					{
						if (prod2.GetBitLength() != xLen)
							Console.WriteLine($"incorrect Length:prod2[{prod2.GetBitLength()}] of xLen:{xLen}  (miss by {prod2.GetBitLength() - xLen}) correctBits:{score}"); //{ToBinaryString(prod1)} {prod1}
						else
							Console.WriteLine($"fail correctBits:{score} of {xLen}");
					}
				else  // numOfNewtonSteps > 0
				{

				}
			}
			result = bestResult;
		}




		Console.WriteLine($"Result:{ToBinaryShades(result)} [{result.GetBitLength()}]");
		//desiredStartSize = doubleDesiredStartSize - EXTRA_BITS_TO_REMOVE;
		//numOfNewtonSteps--;
		//doubleDesiredStartSize = (desiredStartSize << 1);
		//xTimesY = ((x >> (xLen - doubleDesiredStartSize)) * result) >> (desiredStartSize - 1);


		// NewtonPlus (scan for working) 
		if (false)
		{ 
			bool firstDisplay = true;
			int checkResultSize = (int)checkResult.GetBitLength();
			int end = 4; int fails = 0; int found = 0;
			BigInteger prod2 = 0;
			for (int i = 0; i <= end; i = (i == 0) ? 1 : (i > 0 ? -i : -i + 1))
			for (int j = 0; j <= end; j = (j == 0) ? 1 : (j > 0 ? -j : -j + 1))
			for (int k = 0; k <= end; k = (k == 0) ? 1 : (k > 0 ? -k : -k + 1))
			for (int m = 0; m <= end; m = (m == 0) ? 1 : (m > 0 ? -m : -m + 1))
			for (int n = 0; n <= end; n = (n == 0) ? 1 : (n > 0 ? -n : -n + 1))
			for (int p = 0; p <= end; p = (p == 0) ? 1 : (p > 0 ? -p : -p + 1))
			{    int preSum = Math.Abs(i) + Math.Abs(j) + Math.Abs(k) + Math.Abs(m) + Math.Abs(n) + Math.Abs(p);
				 if (preSum  > end) continue;
			for (int q = 0; q <= end; q = (q == 0) ? 1 : (q > 0 ? -q : -q + 1))
			for (int r = 0; r <= end; r = (r == 0) ? 1 : (r > 0 ? -r : -r + 1))
			for (int s = 0; s <= end; s = (s == 0) ? 1 : (s > 0 ? -s : -s + 1))
			for (int t = 0; t <= end; t = (t == 0) ? 1 : (t > 0 ? -t : -t + 1))
			for (int u = 1; u <= end; u = (u == 0) ? 1 : (u > 0 ? -u : -u + 1))
			for (int v = 0; v <= end; v = (v == 0) ? 1 : (v > 0 ? -v : -v + 1))
			for (int w = 0; w <= end; w = (w == 0) ? 1 : (w > 0 ? -w : -w + 1))
			for (int y = 0; y <= end; y = (y == 0) ? 1 : (y > 0 ? -y : -y + 1))
			{   /*int w = 1;*/ int changeSum = preSum + Math.Abs(q-1) + Math.Abs(r) + Math.Abs(s) + Math.Abs(t) + Math.Abs(u-1) + Math.Abs(v) + Math.Abs(w-1);
				if (Math.Abs(u) == 0 /*|| (Math.Abs(v) == 0) */ || changeSum > end)
					continue;
				BigInteger result2 = (result >> v) + w;
				BigInteger mask22 = (BigInteger.One << (desiredStartSize+i)) - 1;
				BigInteger xTimesY22 = (((x >> (xLen - doubleDesiredStartSize + j)) + r) * (result2 + k)) >> (desiredStartSize - 1 + m);
				prod2 = ((result2 + q) << (doubleDesiredStartSize + t)) - u * ((result2 + n) * (((xTimesY22 + s) & mask22) - p));

				// Check Result
				int bitsToHide = 0;
				int prod2Size = (int)prod2.GetBitLength();
				BigInteger checkResult2 = 0;
				if (checkResultSize > prod2Size)
				{
					checkResult2 = checkResult >> (checkResultSize + bitsToHide - prod2Size);
					prod2 >>= bitsToHide;
				}
				else
				{
					checkResult2 = checkResult >> bitsToHide;
					prod2 >>= (prod2Size + bitsToHide - checkResultSize);
				}

				//prod1b |= mask2;
				//prod2  |= mask2;
				//Console.WriteLine($"Mask:{ToBinaryString(mask2)}");

				if (checkResult2 >> 5 == prod2 >> 5)// || (prod1>>1) == prod2 || prod1 == (prod2>>1) || (prod1 >> 1) == (prod2 >> 1) || (prod1 >> 2) == prod2 || prod1 == (prod2 >> 2) || (prod1 >> 2) == (prod2 >> 2))
				{
					//Console.WriteLine($"match: {fails} {ToBinaryString(prod1)}");
					if (firstDisplay == true)
						Console.WriteLine($"Sum	i	j	k	m	n	p	q	r	s	t	u	v	w");
					else
						Console.WriteLine($"{changeSum,2}	{i,2}	{j,2}	{k,2}	{m,2}	{n,2}	{p,2}	{q,2}	{r,2}	{s,2}	{t,2}	{u,2}	{v,2}	{w,2}");
					found++; firstDisplay = false;
					//Console.WriteLine($"prod1: {ToBinaryString(prod1b)}");
					//Console.WriteLine($"prod2: {ToBinaryString(prod2)}");
					//goto doneWithScan;
					//if (found > 4)
					//{ goto skippp; }
				}
				else
				{
					////Console.WriteLine($"{ToBinaryString(result)}|{ToBinaryString((BigInteger.One << doubleDesiredStartSize) - ((result + adj) * ((xTimesY & mask) - 0)))}");
					//if (fails == 0)
					//{
					//    Console.WriteLine($"prod1: {ToBinaryString(prod1b)}");
					//    Console.WriteLine($"prod2: {ToBinaryString(prod2)}");
					//    //Console.WriteLine($"{x}");
					//    //Console.WriteLine($"{ToBinaryString(x)}");
					//                                                //Console.WriteLine($"{ToBinaryString(prod1b-prod2)}");
					//                                            }
					//fails++;
				}
			}}
			//if (found <4)
			//{ }

			skippp:
			if (numOfNewtonSteps == 0)
				return prod2 >> (doubleDesiredStartSize - precisionBits);
			//Console.WriteLine($"{(found? "match" : "miss")}: [{fails}]"); //{ToBinaryString(prod1)} {prod1}
		}

		// back off until we see both a zero and one??

		result >>=  precisionBits - doubleDesiredStartSize;
		result >>= EXTRA_BITS_TO_REMOVE;


		int reduceBy = 0;
		if (result.IsEven)
			reduceBy = (int)BigInteger.TrailingZeroCount(result) + 1;
		else
			reduceBy = (int)BigInteger.TrailingZeroCount(~result) + 1;  //todo: need to check more then just 64 bits! (also, a loop might be faster going bit by bit)

		Console.WriteLine($"Ans_Bits:{ToBinaryShades((checkResult >> ((int)checkResult.GetBitLength() - (int)result.GetBitLength())) & 0xFFF),14}");
		Console.WriteLine($"LastBits:{ToBinaryShades(result & 0xFFF, 14)} >> {reduceBy}");
		//Console.WriteLine($"LastBits:{ToBinaryShades(~result & 0xFFF, 14)}");
		 
		if (desiredStartSize > 600)
		{ }
		 
		if (desiredStartSize > xLen)
		{
			result >>= (desiredStartSize - xLen);
			if (checkResult == result >> (desiredStartSize - xLen))
			{
				Console.WriteLine($"match and {desiredStartSize} > {xLen} "); //{ToBinaryString(prod1)} {prod1}
				if (numOfNewtonSteps == 0)
					return result;
			}
			else
			{
				if (result.GetBitLength() != xLen)
					Console.WriteLine($"incorrect Length:prod2[{result.GetBitLength()}] of xLen:{xLen}  (miss by {result.GetBitLength() - xLen})"); //{ToBinaryString(prod1)} {prod1}
				else
					Console.WriteLine($"fail {xLen}");
			}
		}
		else
		{
			result >>= reduceBy;
			desiredStartSize = doubleDesiredStartSize - reduceBy - EXTRA_BITS_TO_REMOVE;
		}
	}
}

public static BigInteger InverseBigInteger5(BigInteger x, int precisionBits)
{

	int xLen = (int)x.GetBitLength();
	if (precisionBits > xLen)
	{
		throw new DivideByZeroException("'precisionBits' can not be greater then x's length.");
	}


	//if (x.IsZero) // not needed since code below throws error
	//    throw new DivideByZeroException("Cannot compute the inverse of zero.");

	bool isPos = x.Sign >= 0;
	if (!isPos)
		x = -x;

	//if (x.GetBitLength() != precisionBits)
	//    throw new DivideByZeroException("TEST ERROR");

	//if (precisionBits < 53)
	//    return (BigInteger)(((double)(UInt128.One << (2 * precisionBits - 1))) / (double)x);

	if (xLen < 65)
	{
		if (xLen < 33)
		{
			ulong res = (1UL << 63) / (ulong)x; // 63 /  31
			res >>= 64 - (int)ulong.LeadingZeroCount(res) - precisionBits;
			return isPos ? res : (-(BigInteger)res);
		}
		else
		{
			UInt128 res = (UInt128.One << 127) / (ulong)x;
			res >>= (int)UInt128.Log2(res) - precisionBits + 1; //what about uint.Log2(res>>32) +32
			return isPos ? res : (-(BigInteger)res);
		}
	}

	if (xLen < 512)
	{
		BigInteger res = (BigInteger.One << (xLen + precisionBits - 1)) / x;
		//if ((int)BigInteger.Log2(res) + 1 != precisionBits)
		//{
		//    Console.WriteLine("XXXXXX");
		//}
		//res >>= ((int)BigInteger.Log2(res) + 1 - precisionBits);
		return res;
	}


	//if (xLen < 128)
	//{
	//    int desiredStartSize2 = precisionBits + 10;
	//    while (desiredStartSize2 > 64)
	//        desiredStartSize2 = ((desiredStartSize2) >> 1) + 1;

	//    UInt128 res = (UInt128.One << 127) / (ulong)(x >> (xLen - 64 + 1));
	//    BigInteger result2 = res >> ((int)UInt128.Log2(res) - desiredStartSize2 + 1); //we know UInt128.Log2(res) is 64?

	//    //BigInteger scaledOne3 = BigInteger.One << ((desiredStartSize2 << 1) + 0);
	//    //BigInteger result2 = (scaledOne3 / (x >> (xLen - desiredStartSize2 - 0 - 1)));

	//    //if (result2 != result3)
	//    //{ }
	//    //else
	//    //{ } 

	//    BigInteger scalingFactor = BigInteger.One << ((desiredStartSize2 << 1) + 1);
	//    BigInteger xTimesY = ((x >> (xLen - (desiredStartSize2 << 1))) * result2) >> (desiredStartSize2 - 1);
	//    BigInteger twoMinusXy = scalingFactor - xTimesY;
	//    result2 = (result2 * twoMinusXy) >> desiredStartSize2;
	//    desiredStartSize2 <<= 1;

	//    //if ((int)result.GetBitLength() != doubleDesiredStartSize)  { }
	//    result2 >>= ((desiredStartSize2) - precisionBits);

	//    return (isPos) ? result2 : -result2;
	//}

	//int bytes = x.GetByteCount();


	//if (x.IsPowerOfTwo)
	//    return x.Sign * BigInteger.One << (precisionBits - 1);


	//const int ExtraPrecision = 4;
	//if (precisionBits <= UseSimpleForSizesUnder)
	//{
	//    // Lets pre-scale x and just do simple BigInteger integer division
	//    BigInteger scaledOne = BigInteger.One << ((precisionBits << 1) + ExtraPrecision);
	//    return scaledOne / (x >> (xLen - precisionBits - ExtraPrecision - 1));
	//}

	////////  Get Starting Size  ////////
	//int numOfNewtonSteps = BitOperations.Log2((uint)(wantedPrecision / size)) + 2;
	//int wantedSize = (wantedPrecision >> numOfNewtonSteps) + 2;

	int desiredStartSize = precisionBits + 16;
	int numOfNewtonSteps = 0;
	while (desiredStartSize > 325)
	{
		desiredStartSize = (desiredStartSize >> 1) + 1;
		numOfNewtonSteps++;
	}


	//int desiredStartSize2 = precisionBits + 16;
	//int numOfNewtonSteps = BitOperations.Log2((uint)((desiredStartSize2) / 325)) + 1;
	//int desiredStartSize = (desiredStartSize2 >> numOfNewtonSteps) + 2;

	BigInteger scaledOne2 = BigInteger.One << (desiredStartSize << 1);
	BigInteger result = scaledOne2 / (x >> (xLen - desiredStartSize - 1));




	while (true)
	{
		numOfNewtonSteps--;
		int doubleDesiredStartSize = (desiredStartSize << 1);
		BigInteger scalingFactor = BigInteger.One << (doubleDesiredStartSize + 1);
		//BigInteger x2 = (x >> (xLen - doubleDesiredStartSize)) & mask; //~((x >> (xLen - doubleDesiredStartSize)) & mask) & mask;
		BigInteger xTimesY = (x >> (xLen - doubleDesiredStartSize)) * result >> (desiredStartSize - 1);
		//BigInteger xTimesY2 = (x >> (xLen - doubleDesiredStartSize)) & mask * result; // >> (desiredStartSize - 1-18);
		BigInteger twoMinusXy = scalingFactor - xTimesY;

		//BigInteger twoMinusXy1 =  ~(xTimesY & mask) & mask; 


		//Console.WriteLine($"{ToBinaryString(xTimesY1)}");
		////Console.WriteLine($"{ToBinaryString(xTimesY2)}");

		BigInteger mask = (BigInteger.One << desiredStartSize) - 1;
		Console.WriteLine($"{ToBinaryString(twoMinusXy)}");
		Console.WriteLine($"{ToBinaryString(twoMinusXy & mask)}");

		Console.WriteLine($"{ToBinaryString(result)}");

		BigInteger prod1 = result * twoMinusXy;
		BigInteger prod2 = (BigInteger.One << doubleDesiredStartSize) - (result * (xTimesY & mask));
		Console.WriteLine($"{ToBinaryString(prod1)}");
		Console.WriteLine($"{ToBinaryString(prod2)}");

		if (numOfNewtonSteps > 0)
			result = prod1 >> desiredStartSize;
		else
			return prod1 >> (desiredStartSize + doubleDesiredStartSize - precisionBits);

		desiredStartSize = doubleDesiredStartSize;
	}
}


//tuning stuff
//int A = 0; int B = 0; int C = 0; int D = 0;
//BigInteger scalingFactor = BigInteger.One >> (-2 * desiredStartSize - 1 + B + D);
//BigInteger xTimesY = ((x >> (xLen - 2 * desiredStartSize + A + D)) * result) >> (desiredStartSize - 1 + B - A);
//BigInteger twoMinusXy = (scalingFactor - xTimesY) >> (-B + C + D);
//result = (result* twoMinusXy) >> (desiredStartSize - C + 0);
//if (ToBinaryString(result4).Zip(ToBinaryString(result2), (c1, c2) => c1 == c2).TakeWhile(b => b).Count() >= 1293 && (int)result4.GetBitLength() == 1296)
//   Console.WriteLine($" Correct: {ToBinaryString(result).Zip(ToBinaryString(result2), (c1, c2) => c1 == c2).TakeWhile(b => b).Count()} of {result.GetBitLength()}");


// ChatGPT 10/8/2024 - o1 preview  
public static BigInteger InverseBigInteger4(BigInteger x, int precisionBits)
{
	if (x.IsZero)
		throw new DivideByZeroException("Cannot compute the inverse of zero.");

	bool isNegative = x.Sign < 0;
	if (isNegative)
		x = BigInteger.Abs(x);

	// Scaling factor: 2^(2 * precisionBits)
	BigInteger scalingFactor = BigInteger.One << (2 * precisionBits);

	BigInteger result;

	// Try using ulong for the initial division if possible
	if (x <= uint.MaxValue && (2 * precisionBits) <= 63)
	{
		// Use uint for x and scaling factor to prevent overflow
		uint xULong = (uint)x;
		ulong scalingULong = 1UL << (2 * precisionBits);

		// Perform division using ulong
		ulong initialInverse = scalingULong / xULong;
		result = new BigInteger(initialInverse);
	}
	else if (x <= ulong.MaxValue && (2 * precisionBits) <= 63)
	{
		// Use BigInteger for scaling factor to prevent overflow
		BigInteger scalingULong = BigInteger.One << (8 * precisionBits);

		// Perform division using BigInteger (since scaling factor might be large)
		result = scalingULong / x;
	}
	else
	{
		// Fall-back to using double for initial approximation
		double xDouble = (double)x;
		double scalingDouble = Math.Pow(2, 2 * precisionBits);

		// Perform division using double
		double initialInverseDouble = scalingDouble / xDouble;
		result = new BigInteger(initialInverseDouble);
	}

	// If high precision is required, refine the result using Newton-Raphson method
	if (precisionBits > 64)
	{
		result = InverseUsingNewtonRaphson(x, precisionBits, result);
	}

	if (isNegative)
		result = -result;

	return result;

	static BigInteger InverseUsingNewtonRaphson(BigInteger x, int precisionBits, BigInteger initialApproximation)
	{
		// Scaling factor: 2^(precisionBits)
		BigInteger scalingFactor = BigInteger.One << precisionBits;

		BigInteger y = initialApproximation;

		// Number of iterations for convergence
		int iterations = (int)Math.Ceiling(Math.Log2(precisionBits)) + 1;

		for (int i = 0; i < iterations; i++)
		{
			// y = y * (2 * scalingFactor - x * y) / scalingFactor
			BigInteger xTimesY = (x * y) >> precisionBits;
			BigInteger twoMinusXy = (scalingFactor << 1) - xTimesY;
			y = (y * twoMinusXy) >> precisionBits;
		}

		return y;
	}
}



// ChatGPT 10/8/2024 - o1 preview
public static BigInteger InverseBigInteger3(BigInteger x, int precisionBits)
{
	if (x.IsZero)
		throw new DivideByZeroException("Cannot compute the inverse of zero.");

	bool isNegative = x.Sign < 0;
	if (isNegative)
		x = BigInteger.Abs(x);

	// Scaling factor: 2^(precisionBits)
	BigInteger scalingFactor = BigInteger.One << precisionBits;

	// Use higher scaling factor for initial approximation
	BigInteger initialScalingFactor = BigInteger.One << (precisionBits * 2);

	// Initial approximation
	
	BigInteger y = (initialScalingFactor>>8) / (x>>8);

	// Number of iterations
	int iterations = (int)Math.Ceiling(Math.Log(precisionBits) / Math.Log(2)) + 1;

	//int iterations2 = BitOperations.Log2((uint)(x.GetBitLength()/ precisionBits)) + 2;

	for (int i = 0; i < iterations; i++)
	{
		// y = y * (2 * scalingFactor - x * y) / scalingFactor
		BigInteger xTimesY = (x * y) >> precisionBits;
		BigInteger twoMinusXy = (scalingFactor << 1) - xTimesY;
		y = (y * twoMinusXy) >> precisionBits;
	}

	if (isNegative)
		y = -y;

	return y;
}

// ChatGPT 10/8/2024 - o1 preview  (version 2 by ChatGPT after feedback)

//public static BigInteger InverseBigInteger2(BigInteger x, int precisionBits)
//{
//    if (x.IsZero)
//        throw new DivideByZeroException("Cannot compute the inverse of zero.");

//    bool isNegative = x.Sign < 0;
//    if (isNegative)
//        x = BigInteger.Abs(x);

//    // Scaling factor: 2^(precisionBits)
//    BigInteger scalingFactor = BigInteger.One << precisionBits;

//    // Use higher scaling factor for initial approximation
//    BigInteger initialScalingFactor = BigInteger.One << (precisionBits * 2);

//    // Initial approximation
//    BigInteger y = initialScalingFactor / x;

//    // Number of iterations
//    int iterations = (int)Math.Ceiling(Math.Log(precisionBits) / Math.Log(2)) + 1;

//    for (int i = 0; i < iterations; i++)
//    {
//        // y = y * (2 * scalingFactor - x * y) / scalingFactor
//        BigInteger xTimesY = (x * y) >> precisionBits;
//        BigInteger twoMinusXy = (scalingFactor << 1) - xTimesY;
//        y = (y * twoMinusXy) >> precisionBits;
//    }

//    if (isNegative)
//        y = -y;

//    return y;
//}

// ChatGPT 10/7/2024 - o1 preview  (version 1)
public static BigInteger InverseBigInteger1(BigInteger x, int precisionBits)
{
	if (x.IsZero)
		throw new DivideByZeroException("Cannot compute the inverse of zero.");

	bool isNegative = x.Sign < 0;
	if (isNegative)
		x = BigInteger.Abs(x);

	// Scaling factor: 2^precisionBits
	BigInteger scalingFactor = BigInteger.One << precisionBits;

	// Initial approximation (can be improved)
	BigInteger y = scalingFactor / x;

	// Number of iterations (log2(precisionBits)) for convergence
	int iterations = (int)Math.Ceiling(Math.Log(precisionBits) / Math.Log(2)) + 1;

	for (int i = 0; i < iterations; i++)
	{
		// y = y * (2 * scalingFactor - x * y) / scalingFactor
		BigInteger xTimesY = (x * y) >> precisionBits;
		BigInteger twoMinusXy = (BigInteger.One << 1) * scalingFactor - xTimesY;
		y = (y * twoMinusXy) >> precisionBits;
	}

	if (isNegative)
		y = -y;

	return y;
}