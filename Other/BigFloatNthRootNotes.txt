   //////////////  NthRoot Play Area & Examples ////////////// as of 1/6/2024
   private static void NthRoot_DRAFT_Stuff()
   {
       Console.WriteLine($"Ans: val^(1/3) -> 26260231.868889058659811670527341)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("77777777777777777777777777777777")>>32, 3)}");
       Console.WriteLine($"Ans: val^(1/3) -> 42685972166.249808508213684454450)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("77777777777777777777777777777777"), 3)}");
       Console.WriteLine($"Ans: val^(1/2) -> 8944271909999158.7856366946749251)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("80000000000000000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 43088693800.637674435185871330387)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("80000000000000000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 94574160.900317581330169611988722)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("80000000000000000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 2402248.8679628624664841997871983)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("80000000000000000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 207578.16311124268746614482713121)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("80000000000000000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/7) -> 36106.407876409947138175505843180)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("80000000000000000000000000000000"), 7)}");
       Console.WriteLine($"Ans: val^(1/8) -> 9724.9247246607303150644442684673)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("80000000000000000000000000000000"), 8)}");
       Console.WriteLine($"Ans: val^(1/2) -> 1000000000000000.0000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 10000000000.000000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 31622776.601683793319988935444327)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 1000000.0000000000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 100000.00000000000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/7) -> 19306.977288832501670070747998402)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000000000"), 7)}");
       Console.WriteLine($"Ans: val^(1/8) -> 5623.4132519034908039495103977648)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000000000"), 8)}");
       Console.WriteLine($"Ans: val^(1/2) -> 10000000000000.000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 464158883.36127788924100763509194)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 3162277.6601683793319988935444327)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 158489.31924611134852021013733915)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 21544.346900318837217592935665194)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/7) -> 5179.4746792312111347551746779610)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000000"), 7)}");
       Console.WriteLine($"Ans: val^(1/8) -> 1778.2794100389228012254211951927)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000000"), 8)}");
       Console.WriteLine($"Ans: val^(1/2) -> 3162277660168.3793319988935444327)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 215443469.00318837217592935665194)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 1778279.4100389228012254211951927)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 100000.00000000000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 14677.992676220695409205171148169)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/7) -> 3727.5937203149401661724906094730)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000000"), 7)}");
       Console.WriteLine($"Ans: val^(1/8) -> 1333.5214321633240256759317152953)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000000"), 8)}");
       Console.WriteLine($"Ans: val^(1/2) -> 1000000000000.0000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 100000000.00000000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 1000000.0000000000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 63095.734448019324943436013662234)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 10000.000000000000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/7) -> 2682.6957952797257476988026806276)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000"), 7)}");
       Console.WriteLine($"Ans: val^(1/8) -> 1000.0000000000000000000000000000)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000000"), 8)}");
       Console.WriteLine($"Ans: val^(1/2) -> 316227766016.83793319988935444327)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 46415888.336127788924100763509194)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 562341.32519034908039495103977648)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 39810.717055349725077025230508775)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 6812.9206905796128549798817963002)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/7) -> 1930.6977288832501670070747998402)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000"), 7)}");
       Console.WriteLine($"Ans: val^(1/8) -> 749.89420933245582730218427561514)"); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000000"), 8)}");
       Console.WriteLine($"Ans: val^(1/2) -> 100000000000.000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 21544346.9003188)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 316227.766016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 25118.8643150958)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 4641.58883361278)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("10000000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 31622776601.6838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 9999999.99999997)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 177827.941003892)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 15848.9319246111)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 3162.27766016837)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("1000000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 10000000000.0000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000"), 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 4641588.83361278)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000"), 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 100000.000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000"), 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 10000.0000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000"), 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 2154.43469003188)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(BigFloat.Parse("100000000000000000000"), 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 3162277660.16838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 2154434.69003188)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 56234.1325190350)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 6309.57344480194)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 1467.79926762207)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 1000000000.00000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 1000000.00000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 31622.7766016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 3981.07170553497)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 1000.00000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 316227766.016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 464158.883361278)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 17782.7941003892)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 2511.88643150958)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 681.292069057961)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 100000000.000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 215443.469003189)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 10000.0000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 1584.89319246112)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 464.158883361278)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 31622776.6016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 99999.9999999998)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 5623.41325190349)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 1000.00000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 316.227766016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 10000000.0000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 46415.8883361278)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 3162.27766016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 630.957344480194)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 215.443469003188)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 3162277.66016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 21544.3469003188)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 1778.27941003892)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 398.107170553497)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 146.779926762207)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 1000000.00000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 9999.99999999999)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 1000.00000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 251.188643150958)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 100.000000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 316227.766016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 4641.58883361278)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 562.341325190349)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 158.489319246111)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 68.1292069057961)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(100000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 100000.000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 2154.43469003188)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 316.227766016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 100.000000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 46.4158883361278)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(10000000000, 6)}");
       Console.WriteLine($"Ans: val^(1/2) -> 31622.7766016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000, 2)}");
       Console.WriteLine($"Ans: val^(1/3) -> 1000.00000000000)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000, 3)}");
       Console.WriteLine($"Ans: val^(1/4) -> 177.827941003892)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000, 4)}");
       Console.WriteLine($"Ans: val^(1/5) -> 63.0957344480193)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000, 5)}");
       Console.WriteLine($"Ans: val^(1/6) -> 31.6227766016838)                 "); Console.WriteLine($"  Res: {BigFloat.NthRootDRAFT8(1000000000, 6)}");


       Stopwatch timer = Stopwatch.StartNew();
       BigFloat result = BigFloat.NthRootDRAFT8(new BigFloat((ulong)3 << 60, -60), 3);
       Console.WriteLine($"NthRootDRAFT {result} (Correct: 3^(1/3) -> 1.4422495703074083823216383107801)");

       result = BigFloat.NthRootDRAFT8(new BigFloat((BigInteger)3 << 200, -200), 3);
       Console.WriteLine($"NthRootDRAFT {result} (Correct: 3^(1/3) -> 1.4422495703074083823216383107801)");
       
       timer.Stop(); 
       timer.Reset();
       
       for (int i = 2; i >= 0; i--)
           for (int m = 7; m < 300; m *= 31)
               for (int e = 5; e < 10; e++)
               {
                   BigFloat bf = new((ulong)(m) << 60, -60);
                   //timer = Stopwatch.StartNew();
                   timer.Restart();
                   timer.Start();
                   BigFloat result2 = BigFloat.NthRootDRAFT8(bf, e);
                   timer.Stop();
                   if (i == 0) Console.WriteLine($"{m}^(1/{e}) = {result2}  correct:{double.Pow((double)bf, 1 / (double)e)}  ticks {timer.ElapsedTicks}");
               }

       Console.WriteLine(BigFloat.NthRootDRAFT8(100000000000, 5));


   }

=========================================






///////////////////////////////////////////////////////////////////////////////////////////////////



    // 1/6/2024
    public static BigFloat NthRootDRAFT8(BigFloat value, int root)
    {
        //Console.WriteLine();
        bool rootIsNeg = root < 0;
        if (rootIsNeg)
        {
            root = -root;
        }

        bool resultIsPos = value._int.Sign > 0;
        if (!resultIsPos)
        {
            value = -value;
        }

        resultIsPos = resultIsPos || ((root & 1) == 0);

        // Check if Value is zero.
        if (value._int.Sign == 0)
        {
            return BigFloat.ZeroWithSpecifiedLeastPrecision(value.Size);
        }

        // Check for common roots...
        switch (root)
        {
            case 0:
                return OneWithPrecision(value.Size);
            case 1:
                return resultIsPos ? value : -value;
            //case 2:
            //    return resultIsPos ? Sqrt(value) : -Sqrt(value);
                //case 4:
                //    return resultIsPos ? Sqrt(Sqrt(value)) : -Sqrt(Sqrt(value));
        }

        //int xLen = value._size;
        int rootSize = BitOperations.Log2((uint)root);
        int wantedPrecision = (int)BigInteger.Log2(value._int) + rootSize; // for better accuracy for small roots add: "+ rootSize / Math.Pow(( root >> (rootSize - 3)), root) - 0.5"


        //BigInteger val;

        ////////// Lets remove value's scale (and just leave the last bit so scale is 0 or 1) ////////
        int removedScale = value.Scale & ~1;
        int newScale = value.Scale - removedScale;

        ////////// Use double's hardware to get the first 53-bits ////////
        //long tempX = (long)(value._int >> (value._size - 52 /*- newScale*/ +22));
        ////////////////////////////////////////////////////////////////////////////
        long mantissa = (long)(BigInteger.Abs(value._int) >> (value._size - 53)) ^ ((long)1 << 52);
        long exp = value.Exponent + 1023 - 1;// + 52 -4;

        // if exp is oversized for double we need to pull out some exp:
        if (Math.Abs(value.Exponent) > 1021) // future: using 1021(not 1022) to be safe
        {
            // old: (1)Pre: pre=(value<<(preShift*root)) (2)Root: result=pre^(1/root) (3)post: result/(1<<s)
            // new:  (1)Pre: pre=(value>>preShift) (2)Root: result=pre^(1/root) (3)post: result/(2^(-preShift/root)

            //double finalDiv = Math.Pow(2,-value.Exponent/root);
            exp = 0;
        }
        double dubVal = BitConverter.Int64BitsToDouble(mantissa | (exp << 52));
        ///////////////////////////////////////////////////////////////////////////////////////////////
        // todo: what about just casting from BigFloat to double?
        //double test = Math.Log2(dubVal); //Math.Log2((double)tempX);
        double tempRoot = Math.Pow(dubVal, 1.0 / root);  //Math.Pow(tempX, 1.0/root)
        ulong bits = (ulong)BitConverter.DoubleToInt64Bits(tempRoot);
        ulong tempVal = bits & 0x1fffffffffffffL | (1UL << 52);
        int tempExp = (int)((bits >> 52) & 0x7ffL) - 1023 - 20;
        newScale += tempExp;


        // If 53 bits enough precision, lets use that and return.
        //if (value._size < 53)
        //{  //  Shrink result to wanted Precision
        //    int shrinkAmt = (53 - value._size);
        //    BigFloat newVal = new BigFloat(tempVal >> shrinkAmt, newScale + shrinkAmt, value._size);
        //    return newVal;
        //}


        BigInteger xVal = tempVal;
        int x_Scale = newScale;

        //x_Scale -= 100; //TEMP
        //xVal <<= 100; //TEMP

        ////////////////// BigFloat Version ////////////////////////////
        BigFloat x = new((BigInteger)tempVal << 100, newScale - 100, true);
        //BigFloat rt = new((BigInteger)root << value.Size, -value.Size);  // get a proper sized "root" (only needed for BigFloat version)
        //BigFloat b = rt * Pow(x, root - 1); // Init the "b" and "t" for "oldX - (t / b)"
        //BigFloat t = Pow(x, root) - value;
        //while (t._size > 3) //(!t.OutOfPrecision)
        //{
        //    BigFloat oldX = x;
        //    BigFloat tb = t / b;
        //    x -= tb;
        //    Console.WriteLine($"{oldX} - ({t} / {b}) = {oldX} - {tb} =\r\n     {x}");
        //    b = rt * Pow(x, root - 1);
        //    t = Pow(x, root) - value;
        //}
        //BigFloat usingBigFloats = x; //new BigFloat(xVal, x_Scale, true);
        


        BigFloat rt = new((BigInteger)root << value.Size, -value.Size);  // get a proper sized "root" (only needed for BigFloat version)



        BigFloat t = Pow(x, root) - value; Console.WriteLine($"F-t:  {t.GetMostSignificantBits(196)}[{t._size}]");
        BigInteger biPower = PowMostSignificantBits(xVal << 53, root, out int totalShift2);
        BigInteger t2 = (value._int << (int)(biPower.GetBitLength() - value._int.GetBitLength())) - biPower; Console.WriteLine($"I-t:  {BigIntegerToBinaryString(t2)}[{t2.GetBitLength()}]");

        BigFloat b = rt * Pow(x, root - 1);                                             Console.WriteLine($"F-b:  {b.GetMostSignificantBits(196)}[{b._size}]");
        BigInteger b2;
         b2 = root * PowMostSignificantBits(xVal, root - 1, out int totalShift, 53, 53);Console.WriteLine($"I-b:  {BigIntegerToBinaryString(b2)}[{b2.GetBitLength()}]");
        // precision: biPower = 53, t2 = 53, b2 = 53, SO tb2 = 53 bits

        while (xVal.GetBitLength() < 140)//(t2.GetBitLength() > 20)//(t._size > 3) //(!t.OutOfPrecision)
        {
            Console.WriteLine();
                BigFloat oldX = x;
            BigInteger oldX2 = xVal;

                BigFloat tb = t / b;                                            Console.WriteLine($"F-tb: {tb.GetMostSignificantBits(196)}[{tb._size}]");
            BigInteger tb2 = (t2 << 53) / b2;                                   Console.WriteLine($"I-tb: {BigIntegerToBinaryString(tb2)}[{tb2.GetBitLength()}]");
                                                                                 
                x -= tb;                                                        Console.WriteLine($"F-X:  {x.GetMostSignificantBits(196)}[{x._size}]");
            xVal = (xVal << ((int)b2.GetBitLength())) + tb2;                    Console.WriteLine($"I-X:  {BigIntegerToBinaryString(xVal)}[{xVal.GetBitLength()}]");
                                                                                Console.WriteLine($"Ans:  1100100001011001100000111.1101111001101111100000110110101011001011110011100100111000010100010010110001001000010011000000101000010101000000000011011011000010111100110010101111011001011011001110001110");
            Console.WriteLine($"BF:{oldX} - ({t} / {b} [{tb}]) = {x}");
            Console.WriteLine($"BI:{oldX2} - ({t2} / {b2} [{tb2}]) =  {new BigFloat(xVal, x_Scale-54-32)}");

            biPower = PowMostSignificantBits(xVal /*<< 100*/, root, out totalShift2);
            Console.WriteLine($"F-pow:{Pow(x, root).GetMostSignificantBits(196)}[{Pow(x, root)._size}]");
            Console.WriteLine($"I-pow:{BigIntegerToBinaryString(biPower)}[{biPower.GetBitLength()}]");

            BigInteger val2 = (value._int << (int)(biPower.GetBitLength() - value._int.GetBitLength()));
            Console.WriteLine($"F-val:{value.GetMostSignificantBits(196)}[{t._size}]");
            Console.WriteLine($"I-val:{BigIntegerToBinaryString(val2)}[{val2.GetBitLength()}]");

            t = Pow(x, root) - value;                                           Console.WriteLine($"F-t:  {t.GetMostSignificantBits(196)}[{t._size}]");
            t2 = biPower - val2;                                                Console.WriteLine($"I-t:  {BigIntegerToBinaryString(t2)}[{t2.GetBitLength()}]");
                                                                               
            b = rt * Pow(x, root - 1);                                          Console.WriteLine($"F-b:  {b.GetMostSignificantBits(196)}[{b._size}]");
            b2 = root * PowMostSignificantBits(xVal, root - 1, out totalShift); Console.WriteLine($"I-b:  {BigIntegerToBinaryString(b2)}[{b2.GetBitLength()}]");

            // precision: t2 = 106, b2 = 106, SO tb2 = 106 bits

            BigInteger temp = (t2 << (2 * wantedPrecision - (int)t2.GetBitLength())) / b2; Console.WriteLine($"I-tb: {BigIntegerToBinaryString(temp)}[{temp.GetBitLength()}]");

        }

        BigFloat usingBigFloats = x; //new BigFloat(xVal, x_Scale, true);
        BigFloat usingBigInteger = new BigFloat(xVal, x_Scale, true);

        return x;



        //////////////////// BigInteger Version ////////////////////////////
        //      BigFloat rt = new((BigInteger)root << value.Size, -value.Size);  
        //BigInteger rt2 = (BigInteger)root << value.Size;

        //      BigFloat b = rt * Pow(x, root - 1); // Init the "b" and "t" for "oldX - (t / b)"
        //BigInteger tbp = PowMostSignificantBits(xVal, root, out int totalShift, 53, 53);
        //BigInteger tVal = tbp - (value._int >> (value._size - 53));
        //BigInteger top_Scale = value._size - 53;

        //       BigFloat t = Pow(x, root) - value;
        //BigInteger ttp = PowMostSignificantBits(xVal, root - 1, out totalShift, 53, 53);
        //BigInteger bVal = (rt2 * ttp) >> 32;
        //BigInteger bot_Scale = 1;

        ////while (tVal > 23) // tVal > 23
        //while (t._size > 3)
        //{
        //    BigFloat oldX = x;
        //    BigInteger oldX_Val = xVal;
        //    BigInteger oldX_Sca = x_Scale;

        //        BigFloat tb = t / b;
        //    BigInteger tbVal = (tVal / bVal);

        //        x -= tb;
        //    xVal -= tbVal;

        //        Console.WriteLine($"BF:{oldX} - ({t} / {b}) = {oldX} - {tb} =\r\n     {x}");
        //    Console.WriteLine($"BI:Current:  {new BigFloat(xVal << 64, x_Scale - 64, true)}");
        //    Console.WriteLine($"BI:{oldX_Val}<<{oldX_Sca} - ({tVal}<<{top_Scale} / {bVal,3}<<{bot_Scale,3}) = left - {tbVal,3} = {xVal}<<{x_Scale}");

        //        b = rt * Pow(x, root - 1); 
        //    int extra = 16;
        //    BigInteger ttp2 = PowMostSignificantBits(xVal, root - 1, out  totalShift, 53, 53 + extra);
        //    bVal = (rt2 * ttp2) >> (32 + extra);

        //        t = Pow(x, root) - value;
        //    BigInteger tbp2 = PowMostSignificantBits(xVal, root, out totalShift, 53, 53 + extra);
        //    tVal = (tbp2 - (value._int >> (value._size - 53 - extra))) >> extra;  // tbp2 - (value._int >> (value._size - 53));

        //    Console.WriteLine($"BI:{oldX_Val}<<{oldX_Sca} - ({tVal}<<{top_Scale} / {bVal,3}<<{top_Scale,3}) = left - {tbVal,3} = {xVal}<<{x_Scale}");
        //    Console.WriteLine($"BI:Ans: {new BigFloat(xVal, x_Scale, true)} ({xVal} << {x_Scale})");
        //    Console.WriteLine();
        //}

        //Console.WriteLine($"BI:Ans: {new BigFloat(xVal, x_Scale, true)} ({xVal} << {x_Scale})");

        //return new BigFloat(xVal, x_Scale, true);

    }


    // 10/17/2023
    public static BigFloat NthRootDRAFT7b(BigFloat value, int root)
    {
        bool rootIsNeg = root < 0;
        if (rootIsNeg)
        {
            root = -root;
        }

        bool resultIsPos = value._int.Sign > 0;
        if (!resultIsPos)
        {
            value = -value;
        }

        resultIsPos = resultIsPos || ((root & 1) == 0);

        // Check if Value is zero.
        if (value._int.Sign == 0)
        {
            return BigFloat.ZeroWithSpecifiedLeastPrecision(value.Size);
        }

        // Check for common roots...
        switch (root)
        {
            case 0:
                return OneWithPrecision(value.Size);
            case 1:
                return resultIsPos ? value : -value;
            case 2:
                return resultIsPos ? Sqrt(value) : -Sqrt(value);
            //case 4:
            //    return resultIsPos ? Sqrt(Sqrt(value)) : -Sqrt(Sqrt(value));
        }

        //int xLen = value._size;
        int rootSize = BitOperations.Log2((uint)root);
        int wantedPrecision = (int)BigInteger.Log2(value._int) + rootSize; // for better accuracy for small roots add: "+ rootSize / Math.Pow(( root >> (rootSize - 3)), root) - 0.5"



        //BigInteger val;

        ////////// Lets remove value's scale (and just leave the last bit so scale is 0 or 1) ////////
        int removedScale = value.Scale & ~1;
        int newScale = value.Scale - removedScale;

        ////////// Use double's hardware to get the first 53-bits ////////
        //long tempX = (long)(value._int >> (value._size - 52 /*- newScale*/ +22));
        ////////////////////////////////////////////////////////////////////////////
        long mantissa = (long)(BigInteger.Abs(value._int) >> (value._size - 53)) ^ ((long)1 << 52);
        long exp = value.Exponent + 1023 - 1;// + 52 -4;

        // if exp is oversized for double we need to pull out some exp:
        if (Math.Abs(value.Exponent) > 1021) // future: using 1021(not 1022) to be safe
        {
            // old: (1)Pre: pre=(value<<(preShift*root)) (2)Root: result=pre^(1/root) (3)post: result/(1<<s)
            // new:  (1)Pre: pre=(value>>preShift) (2)Root: result=pre^(1/root) (3)post: result/(2^(-preShift/root)

            //double finalDiv = Math.Pow(2,-value.Exponent/root);
            exp = 0;
        }
        double dubVal = BitConverter.Int64BitsToDouble(mantissa | (exp << 52));
        ///////////////////////////////////////////////////////////////////////////////////////////////
        // todo: what about just casting from BigFloat to double?
        //double test = Math.Log2(dubVal); //Math.Log2((double)tempX);
        double tempRoot = Math.Pow(dubVal, 1.0 / root);  //Math.Pow(tempX, 1.0/root)
        ulong bits = (ulong)BitConverter.DoubleToInt64Bits(tempRoot);
        ulong tempVal = bits & 0x1fffffffffffffL | (1UL << 52);
        int tempExp = (int)((bits >> 52) & 0x7ffL) - 1023 - 20;
        newScale += tempExp;


        // If 53 bits enough precision, lets use that and return.
        //if (value._size < 53)
        //{  //  Shrink result to wanted Precision
        //    int shrinkAmt = (53 - value._size);
        //    BigFloat newVal = new BigFloat(tempVal >> shrinkAmt, newScale + shrinkAmt, value._size);
        //    return newVal;
        //}


        BigInteger x_B_Value = tempVal;
        int x_B_Scale = newScale;


        BigInteger root_B_Val   = (BigInteger)root << value.Size;
        BigInteger root_B_Scale = -30;


        // B: (BigInteger Version)
        BigInteger ttp = PowMostSignificantBits(x_B_Value, 53, root - 1, out int totalShift, 53);
        BigInteger bot_B_Val = (root_B_Val * ttp) >> 32;
        BigInteger bot_B_Scale = 1; //  totalShift;
        BigInteger tbp = PowMostSignificantBits(x_B_Value, 53, root, out totalShift, 53);
        BigInteger top_B_Val = tbp - (value._int >> (value._size - 53)) ;
        BigInteger top_B_Scale = value._size - 53; //totalShift;
        // 101101110001101011111111111111111111111111111111110111000000000000000000000000000000    6442450943999995x2^32
        // 10110111000110101111111111111111111111111111111111100                                   6442450943999995x2

        //BigInteger top_B_Val2;

        while (top_B_Val > 3) 
        {

            BigInteger oldX_B_Value = x_B_Value;
            BigInteger oldX_B_Scale = x_B_Scale;


            BigInteger tb_B_Value = (top_B_Val / bot_B_Val);
            BigInteger tb_B_Scale = 0; //??

            x_B_Value -= tb_B_Value;
            //x_B_Scale = ;

            //Console.WriteLine($"{oldX_B_Value}<<{oldX_B_Scale} - ({top_B_Val }<<{top_B_Scale} / {bot_B_Val,3 }<<{bot_B_Scale,3}) = left - {tb_B_Value,3}<<{tb_B_Scale,3} = {x_B_Value}<<{x_B_Scale}");

            int extra = 16;


            BigInteger ttp2 = PowMostSignificantBits(x_B_Value, 53, root - 1, out int totalShift2, 53 + extra);
            bot_B_Val = (root_B_Val * ttp2) >> (32 + extra);
            BigInteger bot_B_Scale2 = 1;

            BigInteger tbp2 = PowMostSignificantBits(x_B_Value, 53, root, out totalShift2, 53 + extra);
            //top_B_Val = tbp2 - (value._int >> (value._size - 53));
            top_B_Val = (tbp2 - (value._int >> (value._size - 53- extra))) >> extra;

            BigInteger top_B_Scale2 = value._size - 53;

            //Console.WriteLine($"{oldX_B_Value}<<{oldX_B_Scale} - ({top_B_Val}<<{top_B_Scale} / {bot_B_Val,3}<<{top_B_Scale,3}) = left - {tb_B_Value,3}<<{tb_B_Scale,3} = {x_B_Value}<<{x_B_Scale}");
            //Console.WriteLine($"Ans: {new BigFloat(x_B_Value,x_B_Scale,true)} ({x_B_Value} << {x_B_Scale})");
            //Console.WriteLine();

        }

        //Console.WriteLine($"Ans: {new BigFloat(x_B_Value, x_B_Scale, true)} ({x_B_Value} << {x_B_Scale})");

        return new BigFloat(x_B_Value, x_B_Scale, true);

    }









    //10/16/2023
    public static BigFloat NthRootDRAFT7(BigFloat value, int root)
    {
        bool rootIsNeg = root < 0;
        if (rootIsNeg)
        {
            root = -root;
        }

        bool resultIsPos = value._int.Sign > 0;
        if (!resultIsPos)
        {
            value = -value;
        }

        resultIsPos = resultIsPos || ((root & 1) == 0);

        // Check if Value is zero.
        if (value._int.Sign == 0)
        {
            return BigFloat.ZeroWithSpecifiedLeastPrecision(value.Size);
        }

        // Check for common roots...
        switch (root)
        {
            case 0:
                return OneWithPrecision(value.Size);
            case 1:
                return resultIsPos ? value : -value;
            //case 2:
            //    return resultIsPos ? Sqrt(value) : -Sqrt(value);
            //case 4:
            //    return resultIsPos ? Sqrt(Sqrt(value)) : -Sqrt(Sqrt(value));
        }

        //int xLen = value._size;
        int rootSize = BitOperations.Log2((uint)root);
        int wantedPrecision = (int)BigInteger.Log2(value._int) + rootSize; // for better accuracy for small roots add: "+ rootSize / Math.Pow(( root >> (rootSize - 3)), root) - 0.5"

        //BigInteger val;

        ////////// Lets remove value's scale (and just leave the last bit so scale is 0 or 1) ////////
        int removedScale = value.Scale & ~1;
        int newScale = value.Scale - removedScale;

        ////////// Use double's hardware to get the first 53-bits ////////
        //long tempX = (long)(value._int >> (value._size - 52 /*- newScale*/ +22));
        ////////////////////////////////////////////////////////////////////////////
        long mantissa = (long)(BigInteger.Abs(value._int) >> (value._size - 53)) ^ ((long)1 << 52);
        long exp = value.Exponent + 1023 - 1;// + 52 -4;

        // if exp is oversized for double we need to pull out some exp:
        if (Math.Abs(value.Exponent) > 1021) // future: using 1021(not 1022) to be safe
        {
            // old: (1)Pre: pre=(value<<(preShift*root)) (2)Root: result=pre^(1/root) (3)post: result/(1<<s)
            // new:  (1)Pre: pre=(value>>preShift) (2)Root: result=pre^(1/root) (3)post: result/(2^(-preShift/root)

            //double finalDiv = Math.Pow(2,-value.Exponent/root);
            exp = 0;
        }
        double dubVal = BitConverter.Int64BitsToDouble(mantissa | (exp << 52));
        ///////////////////////////////////////////////////////////////////////////////////////////////
        // todo: what about just casing from BigFloat to double?
        //double test = Math.Log2(dubVal); //Math.Log2((double)tempX);
        double tempRoot = Math.Pow(dubVal, 1.0 / root);  //Math.Pow(tempX, 1.0/root)
        ulong bits = (ulong)BitConverter.DoubleToInt64Bits(tempRoot);
        ulong tempVal = bits & 0x1fffffffffffffL | (1UL << 52);
        int tempExp = (int)((bits >> 52) & 0x7ffL) - 1023 - 20;
        newScale += tempExp;

        // If 53 bits enough precision, lets use that and return.
        //if (value._size < 53)
        //{  //  Shrink result to wanted Precision
        //    int shrinkAmt = (53 - value._size);
        //    BigFloat newVal = new BigFloat(tempVal >> shrinkAmt, newScale + shrinkAmt, value._size);
        //    return newVal;
        //}

        //A: start with approximant guess
        //BigFloat x_A = new(tempVal, newScale, 53);  // What about when tempVal ix 0xFFFFFFF
        BigFloat x_A = new(tempVal>>49<<49, newScale, 53);  // USE for Debugging the below  //TEMPPPPPPP
        // B: (BigInteger Version)
        BigInteger x_B_Value = tempVal >> 49 << 49; //TEMPPPPPPP
        int x_B_Scale = newScale;

        // A: get a proper sized "root" (only needed for BigFloat version)
        BigFloat root_A = new((BigInteger)root << value.Size, -value.Size);
        // B: (BigInteger Version)
        BigInteger root_B_Val = (BigInteger)root << value.Size;
        BigInteger root_B_Scale = -30;

        int GenSz = 13;

        //A: Init the "b" and "t" for "oldX - (t / b)"
        BigFloat bot_A = root_A * Pow(x_A, root - 1);
        BigFloat top_A = Pow(x_A, root) - value;
        // B: (BigInteger Version)
        BigInteger ttp = PowMostSignificantBits(x_B_Value, 53, root - 1, out int totalShift, 53);
        BigInteger bot_B_Val = (root_B_Val * ttp) >> (32+32- GenSz);
        BigInteger bot_B_Scale = 1; //  totalShift;
        BigInteger tbp = PowMostSignificantBits(x_B_Value, 53, root, out totalShift, 53);
        BigInteger top_B_Val = (tbp - (value._int >> (value._size - 53))) << (19+ GenSz);
        BigInteger top_B_Scale = value._size - 53; //totalShift;


        while (top_A._size > 2) //(!t.OutOfPrecision)
        {
            BigFloat oldX_A = x_A;
            BigInteger oldX_B_Value = x_B_Value;
            BigInteger oldX_B_Scale = x_B_Scale;

            BigFloat tb_A = (top_A / bot_A);
            BigInteger tb_B_Value = (top_B_Val / bot_B_Val);
            BigInteger tb_B_Scale = 0; //??

            x_A -= tb_A;
            x_B_Value -= tb_B_Value;
            //x_B_Scale = ;

            Console.WriteLine($"A:{oldX_A._int}<<{oldX_A.Scale} - ({top_A._int}<<{top_A.Scale} / {bot_A._int,3}<<{bot_A.Scale,3}) = left - {tb_A._int,3}<<{tb_A.Scale,3} = {x_A._int}<<{x_A.Scale}");
            Console.WriteLine($"B:{oldX_B_Value}<<{oldX_B_Scale} - ({top_B_Val}<<{top_B_Scale} / {bot_B_Val,3}<<{bot_B_Scale,3}) = left - {tb_B_Value,3}<<{tb_B_Scale,3} = {x_B_Value}<<{x_B_Scale}");

            bot_A = root_A * Pow(x_A, root - 1);
            BigInteger ttp2 = PowMostSignificantBits(x_B_Value, 0, root - 1, out int totalShift2, 53);
            bot_B_Val = (root_B_Val * ttp2) >> (32 + 32 - GenSz);
            bot_B_Scale = 1;

            top_A = (Pow(x_A, root) - value);// << 19;
            BigInteger tbp2 = PowMostSignificantBits(x_B_Value, 0, root, out totalShift2, 53) << (19 + GenSz);
            BigInteger tbp3 = PowMostSignificantBits(x_B_Value, 0, root, out totalShift2, 53 + (19 + GenSz));
            BigInteger tbp4 = PowMostSignificantBits(x_B_Value, 0, root, out totalShift2, 53 + 0);
            BigInteger tbp6 = PowMostSignificantBits(x_B_Value, 0, root, out totalShift2, 53 + (19 + GenSz+2));
            top_B_Val = (tbp2 - (value._int >> (value._size - 53 - (19 + GenSz)))) ;
            top_B_Scale = value._size - 53;

            //Console.WriteLine($"A:{oldX_A._int}<<{oldX_A.Scale} - ({top_A._int}<<{top_A.Scale} / {bot_A._int,3}<<{bot_A.Scale,3}) = left - {tb_A._int,3}<<{tb_A.Scale,3} = {x_A._int}<<{x_A.Scale}");
            //Console.WriteLine($"B:{oldX_B_Value}<<{oldX_B_Scale} - ({top_B_Val}<<{top_B_Scale} / {bot_B_Val,3}<<{top_B_Scale,3}) = left - {tb_B_Value,3}<<{tb_B_Scale,3} = {x_B_Value}<<{x_B_Scale}");
            Console.WriteLine($"Ans_A: {x_A.DebuggerDisplay}");
            Console.WriteLine($"Ans_B: {new BigFloat(x_B_Value, x_B_Scale, true)} ({x_B_Value} << {x_B_Scale})");
            //Console.WriteLine();
        }

        Console.WriteLine($"Ans_A: {x_A.DebuggerDisplay}");
        Console.WriteLine($"Ans_B: {new BigFloat(x_B_Value, x_B_Scale, true)} ({x_B_Value} << {x_B_Scale})");

        return new BigFloat(x_B_Value, x_B_Scale, true);
        //return x_A;
    }










    public static BigFloat NthRootDRAFT6(BigFloat value, int root)
    {
        bool rootIsNeg = root < 0;
        if (rootIsNeg)
        {
            root = -root;
        }

        bool resultIsPos = value._int.Sign > 0;
        if (!resultIsPos)
        {
            value = -value;
        }

        resultIsPos = resultIsPos || ((root & 1) == 0);

        // Check if Value is zero.
        if (value._int.Sign == 0)
        {
            return BigFloat.ZeroWithSpecifiedLeastPrecision(value.Size);
        }

        // Check for common roots...
        switch (root)
        {
            case 0:
                return OneWithPrecision(value.Size);
            case 1:
                return resultIsPos ? value : -value;
            case 2:
                return resultIsPos ? Sqrt(value) : -Sqrt(value);
                //case 4:
                //    return resultIsPos ? Sqrt(Sqrt(value)) : -Sqrt(Sqrt(value));
        }

        //int xLen = value._size;
        int rootSize = BitOperations.Log2((uint)root);
        _ = (int)BigInteger.Log2(value._int) + rootSize; // for better accuracy for small roots add: "+ rootSize / Math.Pow(( root >> (rootSize - 3)), root) - 0.5"

        //BigInteger val;

        ////////// Lets remove value's scale (and just leave the last bit so scale is 0 or 1) ////////
        int removedScale = value.Scale & ~1;
        int newScale = value.Scale - removedScale;

        ////////// Use double's hardware to get the first 53-bits ////////
        //long tempX = (long)(value._int >> (value._size - 52 /*- newScale*/ +22));
        ////////////////////////////////////////////////////////////////////////////
        long mantissa = (long)(BigInteger.Abs(value._int) >> (value._size - 53)) ^ ((long)1 << 52);
        long exp = value.Exponent + 1023 - 1;// + 52 -4;

        // if exp is oversized for double we need to pull out some exp:
        if (Math.Abs(value.Exponent) > 1021) // future: using 1021(not 1022) to be safe
        {
            // old:
            //   (1)Pre:  pre=(value<<(preShift*root))
            //   (2)Root: result=pre^(1/root)
            //   (3)post: result/(1<<s)
            // new:
            //   (1)Pre   pre=(value>>preShift)
            //   (2)Root: result=pre^(1/root)
            //   (3)post: result/(2^(-preShift/root)

            //double finalDiv = Math.Pow(2,-value.Exponent/root);
            exp = 0;
        }
        double dubVal = BitConverter.Int64BitsToDouble(mantissa | (exp << 52));
        ///////////////////////////////////////////////////////////////////////////////////////////////
        // todo: what about just casing from BigFloat to double?
        //double test = Math.Log2(dubVal); //Math.Log2((double)tempX);
        double tempRoot = Math.Pow(dubVal, 1.0 / root);  //Math.Pow(tempX, 1.0/root)
        ulong bits = (ulong)BitConverter.DoubleToInt64Bits(tempRoot);
        ulong tempVal = (bits & 0x1fffffffffffffL) | (1UL << 52);
        int tempExp = (int)((bits >> 52) & 0x7ffL) - 1023 - 20;
        newScale += tempExp;

        // If 53 bits enough precision, lets use that and return.
        if (value._size < 53)
        {  //  Shrink result to wanted Precision
            int shrinkAmt = 53 - value._size;
            BigFloat newVal = new(tempVal >> shrinkAmt, newScale + shrinkAmt, value._size);
            return newVal;
        }

        // start with approximate guess
        BigFloat x = new(tempVal, newScale, 53);  // What about when tempVal ix 0xFFFFFFF
                                                  //BigFloat x = new((tempVal>> 49) <<49, newScale, 53);  // use for DEBUGGING below

        // get a proper sized "root" (only needed for BigFloat version)
        BigFloat rt = new((BigInteger)root << value.Size, -value.Size);

        // Init the "b" and "t" for "oldX - (t / b)"
        BigFloat b = rt * Pow(x, root - 1);
        BigFloat t = Pow(x, root) - value;

        while (t._size > 2) //(!t.OutOfPrecision)
        {
            BigFloat oldX = x;

            BigFloat tb = t / b;
            x -= tb;
            Console.WriteLine($"{oldX} - ({t} / {b}) = {oldX} - {tb} = {x - tb}");

            b = rt * Pow(x, root - 1);
            t = Pow(x, root) - value;
        }

        return x;
    }
    






    
    public static BigFloat NthRootDRAFT6a(BigFloat value, int root)
    {
        bool rootIsNeg = root < 0;
        if (rootIsNeg)
        {
            root = -root;
        }

        bool resultIsPos = value._int.Sign > 0;
        if (!resultIsPos)
        {
            value = -value;
        }

        resultIsPos = resultIsPos || ((root & 1) == 0);

        // Check if Value is zero.
        if (value._int.Sign == 0)
        {
            return BigFloat.ZeroWithSpecifiedLeastPrecision(value.Size);
        }

        // Check for common roots...
        switch (root)
        {
            case 0:
                return OneWithPrecision(value.Size);
            case 1:
                return resultIsPos ? value : -value;
            //case 2:
            //    return resultIsPos ? Sqrt(value) : -Sqrt(value);
            //case 4:
            //    return resultIsPos ? Sqrt(Sqrt(value)) : -Sqrt(Sqrt(value));
        }

        //int xLen = value._size;
        int rootSize = BitOperations.Log2((uint)root);
        int wantedPrecision = (int)BigInteger.Log2(value._int) + rootSize; // for better accuracy for small roots add: "+ rootSize / Math.Pow(( root >> (rootSize - 3)), root) - 0.5"



        //BigInteger val;

        ////////// Lets remove value's scale (and just leave the last bit so scale is 0 or 1) ////////
        int removedScale = value.Scale & ~1;
        int newScale = value.Scale - removedScale;

        ////////// Use double's hardware to get the first 53-bits ////////
        //long tempX = (long)(value._int >> (value._size - 52 /*- newScale*/ +22));
        ////////////////////////////////////////////////////////////////////////////
        long mantissa = (long)(BigInteger.Abs(value._int) >> (value._size - 53)) ^ ((long)1 << 52);
        long exp = value.Exponent + 1023 - 1;// + 52 -4;

        // if exp is oversized for double we need to pull out some exp:
        if (Math.Abs(value.Exponent) > 1021) // future: using 1021(not 1022) to be safe
        {
            // old: (1)Pre: pre=(value<<(preShift*root)) (2)Root: result=pre^(1/root) (3)post: result/(1<<s)
            // new:  (1)Pre: pre=(value>>preShift) (2)Root: result=pre^(1/root) (3)post: result/(2^(-preShift/root)

            //double finalDiv = Math.Pow(2,-value.Exponent/root);
            exp = 0;
        }
        double dubVal = BitConverter.Int64BitsToDouble(mantissa | (exp << 52));
        ///////////////////////////////////////////////////////////////////////////////////////////////
        // todo: what about just casing from BigFloat to double?
        //double test = Math.Log2(dubVal); //Math.Log2((double)tempX);
        double tempRoot = Math.Pow(dubVal, 1.0 / root);  //Math.Pow(tempX, 1.0/root)
        ulong bits = (ulong)BitConverter.DoubleToInt64Bits(tempRoot);
        ulong tempVal = bits & 0x1fffffffffffffL | (1UL << 52);
        int tempExp = (int)((bits >> 52) & 0x7ffL) - 1023 - 20;
        newScale += tempExp;



        // If 53 bits enough precision, lets use that and return.
        //if (value._size < 53)
        //{  //  Shrink result to wanted Precision
        //    int shrinkAmt = (53 - value._size);
        //    BigFloat newVal = new BigFloat(tempVal >> shrinkAmt, newScale + shrinkAmt, value._size);
        //    return newVal;
        //}


        // start with approximant guess
        BigFloat x = new(tempVal, newScale, 53);  // What about when tempVal ix 0xFFFFFFF
        //BigFloat x = new((tempVal>> 49) <<49, newScale, 53);  // use for DEBUGGING below

        int scale = newScale;

        // get a proper sized "root" (only needed for BigFloat version)
        BigFloat rt = new((BigInteger)root << value.Size, -value.Size);

        // Init the "b" and "t" for "oldX - (t / b)"
        BigFloat b = rt * Pow(x, root - 1);
        BigFloat t = Pow(x, root) - value;

        while (t._size > 2) //(!t.OutOfPrecision)
        {
            BigFloat oldX = x;
            BigFloat tb = (t / b);
            Console.WriteLine($"{oldX} - ({t} / {b}) = {oldX} - {tb} = {x - tb}");

            x -= tb;
            b = rt * Pow(x, root - 1);
            t = Pow(x, root) - value;

        }

        return x;
    }










    public static BigFloat NthRootDRAFT6(BigFloat value, int root)
    {
        bool rootIsNeg = root < 0;
        if (rootIsNeg)
        {
            root = -root;
        }

        bool resultIsPos = value._int.Sign > 0;
        if (!resultIsPos)
        {
            value = -value;
        }

        resultIsPos = resultIsPos || ((root & 1) == 0);

        // Check if Value is zero.
        if (value._int.Sign == 0)
        {
            return BigFloat.ZeroWithSpecifiedLeastPrecision(value.Size);
        }

        // Check for common roots...
        switch (root)
        {
            case 0:
                return OneWithPrecision(value.Size);
            case 1:
                return resultIsPos ? value : -value;
            //case 2:
            //    return resultIsPos ? Sqrt(value) : -Sqrt(value);
            //case 4:
            //    return resultIsPos ? Sqrt(Sqrt(value)) : -Sqrt(Sqrt(value));
        }

        //int xLen = value._size;
        int rootSize = BitOperations.Log2((uint)root);
        int wantedPrecision = (int)BigInteger.Log2(value._int) + rootSize; // for better accuracy for small roots add: "+ rootSize / Math.Pow(( root >> (rootSize - 3)), root) - 0.5"



        //BigInteger val;

        ////////// Lets remove value's scale (and just leave the last bit so scale is 0 or 1) ////////
        int removedScale = value.Scale & ~1;
        int newScale = value.Scale - removedScale;

        ////////// Use double's hardware to get the first 53-bits ////////
        //long tempX = (long)(value._int >> (value._size - 52 /*- newScale*/ +22));
        ////////////////////////////////////////////////////////////////////////////
        long mantissa = (long)(BigInteger.Abs(value._int) >> (value._size - 53)) ^ ((long)1 << 52);
        long exp = value.Exponent + 1023 - 1;// + 52 -4;

        // if exp is oversized for double we need to pull out some exp:
        if (Math.Abs(value.Exponent) > 1021) // future: using 1021(not 1022) to be safe
        {
            // old: (1)Pre: pre=(value<<(preShift*root)) (2)Root: result=pre^(1/root) (3)post: result/(1<<s)
            // new:  (1)Pre: pre=(value>>preShift) (2)Root: result=pre^(1/root) (3)post: result/(2^(-preShift/root)

            //double finalDiv = Math.Pow(2,-value.Exponent/root);
            exp = 0;
        }
        double dubVal = BitConverter.Int64BitsToDouble(mantissa | (exp << 52));
        ///////////////////////////////////////////////////////////////////////////////////////////////
        // todo: what about just casing from BigFloat to double?
        //double test = Math.Log2(dubVal); //Math.Log2((double)tempX);
        double tempRoot = Math.Pow(dubVal, 1.0 / root);  //Math.Pow(tempX, 1.0/root)
        ulong bits = (ulong)BitConverter.DoubleToInt64Bits(tempRoot);
        ulong tempVal = bits & 0x1fffffffffffffL | (1UL << 52);
        int tempExp = (int)((bits >> 52) & 0x7ffL) - 1023 - 20;
        newScale += tempExp;



        // If 53 bits enough precision, lets use that and return.
        //if (value._size < 53)
        //{  //  Shrink result to wanted Precision
        //    int shrinkAmt = (53 - value._size);
        //    BigFloat newVal = new BigFloat(tempVal >> shrinkAmt, newScale + shrinkAmt, value._size);
        //    return newVal;
        //}


        // start with approximant guess
        BigFloat x = new(tempVal, newScale, 53);  // What about when tempVal ix 0xFFFFFFF
        //BigFloat x = new((tempVal>> 49) <<49, newScale, 53);  // use for DEBUGGING below

        int scale = newScale;

        // get a proper sized "root" (only needed for BigFloat version)
        BigFloat rt = new((BigInteger)root << value.Size, -value.Size);

        // Init the "b" and "t" for "oldX - (t / b)"
        BigFloat b = rt * Pow(x, root - 1);
        BigFloat t = Pow(x, root) - value;

        while (t._size > 2) //(!t.OutOfPrecision)
        {
            BigFloat oldX = x;
            BigFloat tb = (t / b);
            Console.WriteLine($"{oldX} - ({t} / {b}) = {oldX} - {tb} = {x - tb}");

            x -= tb;
            b = rt * Pow(x, root - 1);
            t = Pow(x, root) - value;

        }

        return x;
    }








    public static BigFloat NthRootDRAFT5(BigFloat value, int root)
    {
        // start with approximant guess
        BigFloat x = value >> (2 * value.Exponent / 3);

        BigFloat rt = new((BigInteger)root << value.Size, -value.Size);

        BigFloat b = rt * Pow(x, root - 1);
        BigFloat t = Pow(x, root) - value;

        while (!t.IsZero)
        {
            BigFloat oldX = x;
            BigFloat tb = (t / b);
            //Console.WriteLine($"{oldX} - ({t} / {b}) = {oldX} - {tb} = {x - tb}");

            x -= tb;
            b = rt * Pow(x, root - 1);
            t = Pow(x, root) - value;

        }

        return x;
    }

    // interpreted from https://socratic.org/questions/how-do-you-use-newton-s-method-to-approximate-the-value-of-cube-root  (starting point 2 of 2 - uses Newton-Raphson)
    // (i think there is an error here as it takes too many loops)
    public static BigFloat NthRootDRAFT4(BigFloat value, int root)
    {

        BigFloat x = value;

        BigFloat rt = new((BigInteger)root << value.Size, -value.Size);

        for (int i = 0; i < 100; i++)
        {
            BigFloat t = Pow(x, root) - value;
            BigFloat b = rt * Pow(x, root - 1);
            BigFloat oldX = x;
            x -= (t / b);
            //Console.WriteLine($"{oldX} - ({t} / {b}) = {x}");
        }

        return x;
    }

    public static BigFloat NthRootDRAFT3(BigFloat value, int root)
    {
        bool rootIsNeg = root < 0;
        if (rootIsNeg)
        {
            root = -root;
        }

        bool resultIsPos = value._int.Sign > 0;
        if (!resultIsPos)
        {
            value = -value;
        }

        resultIsPos = resultIsPos || ((root & 1) == 0);

        // Check if Value is zero.
        if (value._int.Sign == 0)
        {
            return BigFloat.ZeroWithSpecifiedLeastPrecision(value.Size);
        }

        // Check for common roots...
        switch (root)
        {
            case 0:
                return OneWithPrecision(value.Size);
            case 1:
                return resultIsPos ? value : -value;
            case 2:
                return resultIsPos ? Sqrt(value) : -Sqrt(value);
        }

        //int xLen = value._size;
        int rootSize = BitOperations.Log2((uint)root);
        int wantedPrecision = (int)BigInteger.Log2(value._int) + rootSize; // for better accuracy for small roots add: "+ rootSize / Math.Pow(( root >> (rootSize - 3)), root) - 0.5"



        //BigInteger val;

        ////////// Lets remove value's scale (and just leave the last bit so scale is 0 or 1) ////////
        int removedScale = value.Scale & ~1;
        int newScale = value.Scale - removedScale;

        ////////// Use double's hardware to get the first 53-bits ////////
        //long tempX = (long)(value._int >> (value._size - 52 /*- newScale*/ +22));
        ////////////////////////////////////////////////////////////////////////////
        long mantissa = (long)(BigInteger.Abs(value._int) >> (value._size - 53)) ^ ((long)1 << 52);
        long exp = value.Exponent + 1023 - 1;// + 52 -4;

        // if exp is oversized for double we need to pull out some exp:
        if (Math.Abs(value.Exponent) > 1021) // future: using 1021(not 1022) to be safe
        {
            // old: (1)Pre: pre=(value<<(preShift*root)) (2)Root: result=pre^(1/root) (3)post: result/(1<<s)
            // new:  (1)Pre: pre=(value>>preShift) (2)Root: result=pre^(1/root) (3)post: result/(2^(-preShift/root)

            //double finalDiv = Math.Pow(2,-value.Exponent/root);
            exp = 0;
        }
        double dubVal = BitConverter.Int64BitsToDouble(mantissa | (exp << 52));
        ///////////////////////////////////////////////////////////////////////////////////////////////
        //double test = Math.Log2(dubVal); //Math.Log2((double)tempX);
        double tempRoot = Math.Pow(dubVal, 1.0 / root);  //Math.Pow(tempX, 1.0/root)
        ulong bits = (ulong)BitConverter.DoubleToInt64Bits(tempRoot);
        ulong tempVal = bits & 0x1fffffffffffffL | (1UL << 52);
        int tempExp = (int)((bits >> 52) & 0x7ffL) - 1023 - 20;
        newScale += tempExp;



        // If 53 bits enough precision, lets use that and return.
        //if (value._size < 53)
        //{  //  Shrink result to wanted Precision
        //    int shrinkAmt = (53 - value._size);
        //    BigFloat newVal = new BigFloat(tempVal >> shrinkAmt, newScale + shrinkAmt, value._size);
        //    return newVal;
        //}


        //////////  Shrink result to wanted Precision  ////////

        //set the upper and lower limits with our starting guess
        BigFloat upperBound = new((BigInteger)(tempVal + 1), newScale, 53);  // What about when tempVal ix 0xFFFFFFF
        BigFloat lowerBound = new((BigInteger)(tempVal - 1), newScale, 53);


        int offset = 0;
        while (true)
        {

            offset++;
            BigFloat nval = (upperBound + lowerBound);// >> 1;
            BigFloat tstsq = BigFloat.Pow(nval, root);

            int diff = tstsq.CompareToExact(value);
            if (diff > 0)  // (tstsq > value)
            {
                upperBound = nval;
                lowerBound <<= 1;
                value <<= root;
            }
            if (diff < 0)  // (tstsq < value)
            {
                upperBound <<= 1;
                lowerBound = nval;
                value <<= root;
            }
            //Console.WriteLine($"upperBound({upperBound}) + lowerBound({lowerBound}) ?? tstsq({tstsq}) = {((diff == 0)? lowerBound:nval)}");

            if (diff == 0)
            {
                lowerBound = nval;
                break;
            }
            //if (lowerBound == upperBound )
            if (lowerBound.CompareToExact(upperBound) == 0)
            {
                break;
            }



            //////////  Newton Plus Iterations  ////////
            //int shiftX = xLenMod - (3 * size);
            //BigInteger valSqrd = (val * val * val);// << (size - 1);
            //BigInteger valSU = (value >> shiftX) - valSqrd;
            //val = (val << size) + (valSU / val);
            //size *= 2;

        }

        return lowerBound >> offset;
    }


    public static BigFloat NthRootDRAFT2b(BigFloat value, int root)
    {
        if (root < 1)
        {
            throw new Exception("root must be greater than or equal to 1");
        }

        if (value < 0)
        {
            throw new Exception("value must be a positive integer");
        }

        // Special conditions
        if (value == 1)
        {
            //remainder = 0;
            return 1;
        }
        if (value == 0)
        {
            //remainder = 0;
            return 0;
        }
        if (root == 1)
        {
            //remainder = 0;
            return value;
        }

        ////if (value.GetBitLength() < 50)
        ////{
        ////    BigInteger pwr =(BigInteger)Math.Pow((double)value + 0.5, 1.0 / root);
        ////    remainder = value - pwr * pwr;
        ////    return pwr;
        ////}


        //int xLen = (int)value.GetBitLength();
        //int wantedPrecision = (xLen + 1) / root;

        //BigInteger val;

        ////////// Do the first Sqrt on hardware ////////
        //long tempX = (long)(value >> (xLen - 63));
        //double tempSqrt1 = Math.Pow(tempX, (double)root);
        //val = (ulong)BitConverter.DoubleToInt64Bits(tempSqrt1) & 0x1fffffffffffffL;
        //val |= 1UL << 53;

        //int size = 53;

        ///////// There are a few extra digits here, let's save them. ///////
        //int oversizedBy = size - wantedPrecision;

        //////////  Shrink result to wanted Precision  ////////
        //val >>= oversizedBy;

        //BigInteger pwr = (BigInteger)Math.Pow((double)value + 0.5, 1.0 / root);

        //set the upper and lower limits
        BigFloat upperBound = value;
        BigFloat lowerBound = 0;
        //BigInteger upperBound = val + 20;
        //BigInteger lowerBound = val - 20;

        //BigInteger nval = (upperBound + lowerBound) / 2;
        //BigInteger tstsq = BigInteger.Pow(nval, root);

        int offset = 0;
        while (true)
        {
            offset++;
            BigFloat nval = (upperBound + lowerBound);// >> 1;
            BigFloat tstsq = BigFloat.Pow(nval, root);

            int diff = tstsq.CompareToExact(value);
            if (diff > 0)  // (tstsq > value)
            {
                upperBound = nval;
                lowerBound <<= 1;
                value <<= root;
            }
            if (diff < 0)  // (tstsq < value)
            {
                upperBound <<= 1;
                lowerBound = nval;
                value <<= root;
            }
            if (diff == 0)
            {
                lowerBound = nval;
                break;
            }
            //if (lowerBound == upperBound )
            if (lowerBound.CompareToExact(upperBound) == 0)
            {
                break;
            }


            //////////  Newton Plus Iterations  ////////
            //int shiftX = xLenMod - (3 * size);
            //BigInteger valSqrd = (val * val * val);// << (size - 1);
            //BigInteger valSU = (value >> shiftX) - valSqrd;
            //val = (val << size) + (valSU / val);
            //size *= 2;

        }

        return lowerBound >> (offset - 1);
    }

    public static BigFloat NthRootDRAFT2a(BigFloat value, int root)
    {

        //set the upper and lower limits
        BigFloat upperBound = value;
        BigFloat lowerBound = 0;

        int offset = 0;
        while (true)
        {
            offset++;
            BigFloat nval = (upperBound + lowerBound) >> 1;
            BigFloat tstsq = BigFloat.Pow(nval, root);

            int diff = tstsq.CompareToExact(value);
            if (diff > 0)
            {
                upperBound = nval;
            }
            if (diff < 0)  // (tstsq < value)
            {
                lowerBound = nval;
            }
            if (diff == 0)
            {
                lowerBound = nval;
                break;
            }
            if (lowerBound.CompareToExact(upperBound) == 0)
            {
                break;
            }
        }
        return lowerBound;
    }



    public static BigFloat NthRootDRAFT1(BigFloat value, int root, out BigFloat remainder)
    {
        if (root < 1)
        {
            throw new Exception("root must be greater than or equal to 1");
        }

        if (value < 0)
        {
            throw new Exception("value must be a positive integer");
        }

        // Special conditions
        if (value == 1)
        {
            remainder = 0;
            return 1;
        }
        if (value == 0)
        {
            remainder = 0;
            return 0;
        }
        if (root == 1)
        {
            remainder = 0;
            return value;
        }

        ////if (value.GetBitLength() < 50)
        ////{
        ////    BigInteger pwr =(BigInteger)Math.Pow((double)value + 0.5, 1.0 / root);
        ////    remainder = value - pwr * pwr;
        ////    return pwr;
        ////}


        //int xLen = (int)value.GetBitLength();
        //int wantedPrecision = (xLen + 1) / root;

        //BigInteger val;

        ////////// Do the first Sqrt on hardware ////////
        //long tempX = (long)(value >> (xLen - 63));
        //double tempSqrt1 = Math.Pow(tempX, (double)root);
        //val = (ulong)BitConverter.DoubleToInt64Bits(tempSqrt1) & 0x1fffffffffffffL;
        //val |= 1UL << 53;

        //int size = 53;

        ///////// There are a few extra digits here, let's save them. ///////
        //int oversizedBy = size - wantedPrecision;

        //////////  Shrink result to wanted Precision  ////////
        //val >>= oversizedBy;

        //BigInteger pwr = (BigInteger)Math.Pow((double)value + 0.5, 1.0 / root);

        //set the upper and lower limits
        BigFloat upperBound = value;
        BigFloat lowerBound = 0;
        //BigInteger upperBound = val + 20;
        //BigInteger lowerBound = val - 20;

        //BigInteger nval = (upperBound + lowerBound) / 2;
        //BigInteger tstsq = BigInteger.Pow(nval, root);


        while (true)
        {
            BigFloat nval = (upperBound + lowerBound) >> 1;
            BigFloat tstsq = BigFloat.Pow(nval, root);
            if (tstsq > value)
            {
                upperBound = nval;
            }
            if (tstsq < value)
            {
                lowerBound = nval;
            }
            if (tstsq == value)
            {
                lowerBound = nval;
                break;
            }
            if (lowerBound == upperBound - 1)
            {
                break;
            }


            //////////  Newton Plus Iterations  ////////
            //int shiftX = xLenMod - (3 * size);
            //BigInteger valSqrd = (val * val * val);// << (size - 1);
            //BigInteger valSU = (value >> shiftX) - valSqrd;
            //val = (val << size) + (valSU / val);
            //size *= 2;

        }
        remainder = value - BigFloat.Pow(lowerBound, root);


        //return val;
        return lowerBound;
    }

    public static BigInteger NthRootDRAFT0b(BigInteger value, int root, out BigInteger remainder)
    {

        //set the upper and lower limits
        BigInteger upperBound = value;
        BigInteger lowerBound = 0;
        //BigInteger upperBound = val + 20;
        //BigInteger lowerBound = val - 20;

        //BigInteger nval = (upperBound + lowerBound) / 2;
        //BigInteger tstsq = BigInteger.Pow(nval, root);

        while (true)
        {
            BigInteger nval = (upperBound + lowerBound) >> 1;
            BigInteger tstsq = BigInteger.Pow(nval, root);
            if (tstsq > value)
            {
                upperBound = nval;
            }
            if (tstsq < value)
            {
                lowerBound = nval;
            }
            if (tstsq == value)
            {
                lowerBound = nval;
                break;
            }
            if (lowerBound == upperBound - 1)
            {
                break;
            }


            //////////  Newton Plus Iterations  ////////
            //int shiftX = xLenMod - (3 * size);
            //BigInteger valSqrd = (val * val * val);// << (size - 1);
            //BigInteger valSU = (value >> shiftX) - valSqrd;
            //val = (val << size) + (valSU / val);
            //size *= 2;

        }
        remainder = value - BigInteger.Pow(lowerBound, root);

        //return val;
        return lowerBound;
    }

    // exact source for https://www.codeproject.com/Tips/831816/The-Bisection-Method-and-Calculating-Nth-Roots  (1 of 2 starting points)
    public static BigInteger NthRootDRAFT0(BigInteger value, int root, out BigInteger remainder)
    {
        if (root < 1) throw new Exception("root must be greater than or equal to 1");
        if (value < 0) throw new Exception("value must be a positive integer");

        //special conditions
        if (value == 1)
        {
            remainder = 0;
            return 1;
        }
        if (value == 0)
        {
            remainder = 0;
            return 0;
        }
        if (root == 1)
        {
            remainder = 0;
            return value;
        }

        //set the upper and lower limits
        var upperbound = value;
        var lowerbound = BigInteger.Parse("0");

        while (true)
        {
            var nval = (upperbound + lowerbound) / 2;
            var tstsq = BigInteger.Pow(nval, root);
            if (tstsq > value) upperbound = nval;
            if (tstsq < value)
            {
                lowerbound = nval;
            }
            if (tstsq == value)
            {
                lowerbound = nval;
                break;
            }
            if (lowerbound == upperbound - 1) break;
        }
        remainder = value - BigInteger.Pow(lowerbound, root);
        return lowerbound;
    }
