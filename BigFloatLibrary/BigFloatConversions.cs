// Copyright(c) 2020 - 2025 Ryan Scott White
// Licensed under the MIT License. See LICENSE.txt in the project root for details.

// Code below was generated by ChatGPT 5 Thinking

using System;

namespace BigFloatLibrary;

public readonly partial struct BigFloat : IConvertible
{
    /// <summary>
    /// Always <see cref="TypeCode.Object"/>.
    /// </summary>
    public TypeCode GetTypeCode() => TypeCode.Object;

    // ===== Supported conversions (overflow → OverflowException) =====

    public decimal ToDecimal(IFormatProvider? provider) => (decimal)this;

    public double ToDouble(IFormatProvider? provider)
    {
        // Throw if magnitude exceeds finite double range.
        long biased = (long)BinaryExponent + 1023L; // 1..2046 = normal, <=0 = subnormal/underflow
        if (biased > 2046L) throw new OverflowException("BigFloat cannot fit in Double.");
        return (double)this; // allows subnormals and underflow to ±0
    }

    public float ToSingle(IFormatProvider? provider)
    {
        int biased = BinaryExponent + 127; // 1..254 = normal, <=0 = subnormal/underflow
        if (biased > 254) throw new OverflowException("BigFloat cannot fit in Single.");
        return (float)this; // allows subnormals and underflow to ±0
    }

    public sbyte ToSByte(IFormatProvider? provider) => (sbyte)this;
    public byte ToByte(IFormatProvider? provider) => (byte)this;
    public short ToInt16(IFormatProvider? provider) => (short)this;
    public ushort ToUInt16(IFormatProvider? provider) => (ushort)this;
    public int ToInt32(IFormatProvider? provider) => (int)this;
    public uint ToUInt32(IFormatProvider? provider) => (uint)this;
    public long ToInt64(IFormatProvider? provider) => (long)this;
    public ulong ToUInt64(IFormatProvider? provider) => (ulong)this;
    public Int128 ToInt128(IFormatProvider? provider) => (Int128)this;
    public UInt128 ToUInt128(IFormatProvider? provider) => (UInt128)this;

    public string ToString(IFormatProvider? provider) => ToString(null, provider);

    // ===== Unsupported conversions =====

    public bool ToBoolean(IFormatProvider? provider)
        => throw new InvalidCastException("BigFloat cannot be cast to Boolean.");

    public char ToChar(IFormatProvider? provider)
        => throw new InvalidCastException("BigFloat cannot be cast to Char.");

    public DateTime ToDateTime(IFormatProvider? provider)
        => throw new InvalidCastException("BigFloat cannot be cast to DateTime.");

    /// <summary>
    /// Explicit handling for known types. Everything else delegates through Double.
    /// </summary>
    public object ToType(Type conversionType, IFormatProvider? provider)
    {
        if (conversionType is null) throw new ArgumentNullException(nameof(conversionType));

        if (conversionType == typeof(BigFloat) || conversionType.IsAssignableFrom(typeof(BigFloat)))
            return this;

        switch (Type.GetTypeCode(conversionType))
        {
            case TypeCode.Decimal: return ToDecimal(provider);
            case TypeCode.Double: return ToDouble(provider);
            case TypeCode.Single: return ToSingle(provider);

            case TypeCode.SByte: return ToSByte(provider);
            case TypeCode.Byte: return ToByte(provider);
            case TypeCode.Int16: return ToInt16(provider);
            case TypeCode.UInt16: return ToUInt16(provider);
            case TypeCode.Int32: return ToInt32(provider);
            case TypeCode.UInt32: return ToUInt32(provider);
            case TypeCode.Int64: return ToInt64(provider);
            case TypeCode.UInt64: return ToUInt64(provider);

            case TypeCode.String: return ToString(provider);

            case TypeCode.Boolean:
            case TypeCode.Char:
            case TypeCode.DateTime:
            case TypeCode.Empty:
            case TypeCode.DBNull:
                throw new InvalidCastException($"BigFloat cannot be cast to {conversionType}.");
        }

        // Delegate everything else through a Double to avoid IConvertible recursion.
        double d = ToDouble(provider);
        return Convert.ChangeType(d, conversionType, provider)!;
    }

    // ===== Optional stubs (not part of IConvertible) =====
    // public Int128  ToInt128(IFormatProvider? provider)  => (Int128)this;  // requires .NET 8+
    // public UInt128 ToUInt128(IFormatProvider? provider) => (UInt128)this; // requires .NET 8+
}
